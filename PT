-- PT Hack :3 — Full build: cinematic full-screen intro + refined main GUI
-- Persist across death + one-time intro SFX (rbxassetid://7112183471)

local Players      = game:GetService("Players")
local UIS          = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService   = game:GetService("RunService")
local StarterGui   = game:GetService("StarterGui")
local SoundService = game:GetService("SoundService")

-- Kick if not in the correct place (122675988530857)
-- Put this near the top of the LocalScript, before any other logic runs.

do
	local REQUIRED_PLACE_ID = 122675988530857
	-- Remove the IsStudio() check if you also want this to trigger while testing in Studio.
	if not RunService:IsStudio() and game.PlaceId ~= REQUIRED_PLACE_ID then
		local lp = Players.LocalPlayer
		task.defer(function()
			pcall(function()
				lp:Kick("Wrong game buddy :3")
			end)
		end)
		-- Prevent the rest of the script from continuing
		while true do task.wait(1e6) end
	end
end

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Permanently disable the Roblox inventory (Backpack)
local function disableBackpackPermanently()
	-- Try until Core is ready
	for i = 1, 50 do
		local ok = pcall(function()
			game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		end)
		if ok then break end
		task.wait(0.1)
	end
	-- Reassert on respawn just in case
	game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
		pcall(function()
			game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		end)
	end)
end

-- Call once at startup
disableBackpackPermanently()

-- One-time notification to the local player at script start.
-- Tries Roblox CoreGui notification first; if SetCore isn't ready,
-- shows a custom bottom-right toast instead.

local function sendIntroNotification()
	-- Try Roblox notification
	for i = 1, 30 do
		local ok = pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title    = "TransfurWare",
				Text     = "Script made by: ilovegay1113 on Discord",
				Duration = 6,
				-- Icon = "rbxassetid://<optionalIconId>"
			})
		end)
		if ok then return end
		task.wait(0.1)
	end

	-- Fallback: bottom-right toast (always local-only)
	local playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

	local toastGui = Instance.new("ScreenGui")
	toastGui.Name = "PT_Toast"
	toastGui.IgnoreGuiInset = true
	toastGui.ResetOnSpawn = false
	toastGui.DisplayOrder = 999999
	toastGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	toastGui.Parent = playerGui

	local toast = Instance.new("Frame")
	toast.AnchorPoint = Vector2.new(1,1)
	toast.Position = UDim2.new(1, 340, 1, -12) -- start offscreen right
	toast.Size = UDim2.new(0, 320, 0, 56)
	toast.BackgroundColor3 = Color3.fromRGB(43, 18, 56)
	toast.BackgroundTransparency = 0.08
	toast.BorderSizePixel = 0
	toast.Parent = toastGui

	local c = Instance.new("UICorner", toast) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", toast) s.Color = Color3.fromRGB(170, 82, 205) s.Transparency = 0.25 s.Thickness = 1

	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Text = "Script made by: ilovegay1113"
	label.Font = Enum.Font.Gotham
	label.TextSize = 14
	label.TextColor3 = Color3.new(1,1,1)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.TextWrapped = true
	label.Size = UDim2.new(1, -20, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.Parent = toast

	-- Slide-in
	game:GetService("TweenService")
		:Create(toast, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(1, -12, 1, -12)})
		:Play()

	-- Auto-hide after 6s
	task.delay(6, function()
		local t = game:GetService("TweenService")
			:Create(toast, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				Position = UDim2.new(1, 340, 1, -12),
				BackgroundTransparency = 1
			})
		t:Play()
		t.Completed:Once(function() toastGui:Destroy() end)
	end)
end

-- Call this once at startup (before your intro starts)
sendIntroNotification()

-- Singleton guard: ensure UI is created only once per join/session
if player:GetAttribute("PT_UI_INITIALIZED") then
	-- UI was already built (and persists across death); nothing else to do.
	return
end
player:SetAttribute("PT_UI_INITIALIZED", true)

-- Theme
local BG        = Color3.fromRGB(43, 18, 56)    -- deep purple
local ACCENT    = Color3.fromRGB(66, 47, 88)    -- darker bar
local TAB       = Color3.fromRGB(145, 59, 167)  -- tab idle
local TAB_SEL   = Color3.fromRGB(170, 82, 205)  -- tab active
local CYAN      = Color3.fromRGB(90, 220, 255)  -- neon accent
local MAGENTA   = Color3.fromRGB(255, 105, 230) -- neon accent
local WHITE     = Color3.new(1,1,1)

-- Layout constants
local PAD, TITLE_H, TABS_H, GAP, TAB_W, TAB_GAP = 14, 48, 36, 10, 132, 12

-- Utilities
local function corner(parent, r)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, r or 12)
	c.Parent = parent
	return c
end

local function stroke(parent, color, thickness, transparency)
	local s = Instance.new("UIStroke")
	s.Color = color
	s.Thickness = thickness or 1.25
	s.Transparency = transparency or 0.35
	s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	s.Parent = parent
	return s
end

local function tween(obj, info, props)
	local t = TweenService:Create(obj, info, props)
	t:Play()
	return t
end

----------------------------------------------------------------------
-- ScreenGui for the main app (persists across respawn)
----------------------------------------------------------------------
local gui = Instance.new("ScreenGui")
gui.Name = "TransfurWare"
gui.ResetOnSpawn = false       -- IMPORTANT: keep GUI through death/respawn
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
pcall(function()
	gui.ClipToDeviceSafeArea = true
	gui.ScreenInsets = Enum.ScreenInsets.CoreUISafeInsets
end)
gui.Parent = playerGui

----------------------------------------------------------------------
-- Window shell (centered, aligned)
----------------------------------------------------------------------
local win = Instance.new("Frame")
win.Name = "MainFrame"
win.AnchorPoint = Vector2.new(0.5, 0.5)
win.Position = UDim2.new(0.5, 0, 0.5, 0)
win.Size = UDim2.new(0, 560, 0, 360)
win.BackgroundColor3 = BG
win.BorderSizePixel = 0
win.Visible = false -- revealed after intro
win.Parent = gui
corner(win, 14)

-- Enhanced stroke with glow effect
local winStroke = stroke(win, Color3.fromRGB(200,120,255), 1.5, 0.3)

-- Pulsing glow effect on window border
task.spawn(function()
	while win.Parent do
		tween(winStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), 
			{Transparency = 0.15, Color = Color3.fromRGB(220, 140, 255)})
		task.wait(2)
		tween(winStroke, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), 
			{Transparency = 0.4, Color = Color3.fromRGB(170, 100, 220)})
		task.wait(2)
	end
end)

-- Animated gradient background
local winGrad = Instance.new("UIGradient")
winGrad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0.00, Color3.fromRGB(55, 25, 70)),
	ColorSequenceKeypoint.new(0.50, Color3.fromRGB(43, 18, 56)),
	ColorSequenceKeypoint.new(1.00, Color3.fromRGB(30, 12, 45))
}
winGrad.Rotation = 135
winGrad.Parent = win

-- Animate the gradient rotation (lighter on CPU)
-- Use TweenService instead of per-frame loop
task.spawn(function()
    local ROT_DUR = 6 -- seconds for full rotation
    while win.Parent do
        -- Rotate 360 degrees from current rotation
        local newRot = (winGrad.Rotation + 360) % 360
        local tw = tween(winGrad, TweenInfo.new(ROT_DUR, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false), {Rotation = newRot})
        tw.Completed:Wait()
    end
end)

-- Corner accent lights
local function createCornerLight(anchorX, anchorY, posX, posY)
	local light = Instance.new("Frame")
	light.AnchorPoint = Vector2.new(anchorX, anchorY)
	light.Position = UDim2.new(posX, 0, posY, 0)
	light.Size = UDim2.fromOffset(40, 40)
	light.BackgroundColor3 = MAGENTA
	light.BackgroundTransparency = 0.7
	light.BorderSizePixel = 0
	light.ZIndex = 0
	light.Parent = win
	
	local lightGrad = Instance.new("UIGradient")
	lightGrad.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, MAGENTA),
		ColorSequenceKeypoint.new(1, CYAN)
	}
	lightGrad.Transparency = NumberSequence.new{
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(1, 1)
	}
	lightGrad.Parent = light
	corner(light, 40)
	
	-- Pulse animation
	task.spawn(function()
		task.wait(math.random())
		while light.Parent do
			tween(light, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), 
				{Size = UDim2.fromOffset(50, 50), BackgroundTransparency = 0.5})
			task.wait(1.5)
			tween(light, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), 
				{Size = UDim2.fromOffset(40, 40), BackgroundTransparency = 0.7})
			task.wait(1.5)
		end
	end)
	
	return light
end

createCornerLight(0, 0, 0, 0)     -- Top-left
createCornerLight(1, 0, 1, 0)     -- Top-right
createCornerLight(0, 1, 0, 1)     -- Bottom-left
createCornerLight(1, 1, 1, 1)     -- Bottom-right

-- Inner container for consistent spacing
local container = Instance.new("Frame")
container.BackgroundTransparency = 1
container.Size = UDim2.new(1, -PAD*2, 1, -PAD*2)
container.Position = UDim2.new(0, PAD, 0, PAD)
container.Parent = win

----------------------------------------------------------------------
-- Title bar (draggable)
----------------------------------------------------------------------
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.BackgroundColor3 = ACCENT
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 48)
titleBar.Active = true
titleBar.Parent = container
corner(titleBar, 10)
stroke(titleBar, Color3.fromRGB(255,160,255), 1, 0.4)

-- Gradient overlay for title bar
local titleGrad = Instance.new("UIGradient")
titleGrad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0.0, Color3.fromRGB(75, 50, 95)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(66, 47, 88)),
	ColorSequenceKeypoint.new(1.0, Color3.fromRGB(55, 40, 75))
}
titleGrad.Rotation = 90
titleGrad.Parent = titleBar

-- Shimmer effect overlay
local shimmer = Instance.new("Frame")
shimmer.Name = "Shimmer"
shimmer.BackgroundColor3 = Color3.new(1,1,1)
shimmer.BackgroundTransparency = 0.85
shimmer.BorderSizePixel = 0
shimmer.Size = UDim2.new(0.3, 0, 1, 0)
shimmer.Position = UDim2.new(-0.3, 0, 0, 0)
shimmer.ZIndex = 2
shimmer.Parent = titleBar

local shimmerGrad = Instance.new("UIGradient")
shimmerGrad.Transparency = NumberSequence.new{
	NumberSequenceKeypoint.new(0, 1),
	NumberSequenceKeypoint.new(0.5, 0),
	NumberSequenceKeypoint.new(1, 1)
}
shimmerGrad.Rotation = 90
shimmerGrad.Parent = shimmer

-- Animate shimmer
task.spawn(function()
	while titleBar.Parent do
		tween(shimmer, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), 
			{Position = UDim2.new(1, 0, 0, 0)})
		task.wait(3)
		shimmer.Position = UDim2.new(-0.3, 0, 0, 0)
		task.wait(2)
	end
end)

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = "TransfurWare"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = WHITE
title.TextXAlignment = Enum.TextXAlignment.Left
title.Size = UDim2.new(1, -PAD*2, 1, 0)
  title.Position = UDim2.new(0, PAD, 0, 0)
  title.Parent = titleBar


----------------------------------------------------------------------
-- Tabs row with horizontal scrolling (replaces your tabsStrip Frame block)
----------------------------------------------------------------------
local tabsStrip = Instance.new("ScrollingFrame")
tabsStrip.Name = "TabsStrip"
tabsStrip.Parent = container
tabsStrip.BackgroundTransparency = 1
tabsStrip.Size = UDim2.new(1, 0, 0, TABS_H)
tabsStrip.Position = UDim2.new(0, 0, 0, TITLE_H + GAP)
tabsStrip.BorderSizePixel = 0
tabsStrip.ScrollingDirection = Enum.ScrollingDirection.X
tabsStrip.AutomaticCanvasSize = Enum.AutomaticSize.X
tabsStrip.ScrollBarThickness = 6
tabsStrip.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- theme
tabsStrip.CanvasSize = UDim2.new(0, 0, 0, 0)

local tabsPad = Instance.new("UIPadding", tabsStrip)
tabsPad.PaddingLeft = UDim.new(0, 8)
tabsPad.PaddingRight = UDim.new(0, 8)

-- After you create tabsStrip (ScrollingFrame) and tabsPad:
local SCROLLBAR_GAP = 8  -- how far below the tabs the bar sits

-- Make the strip a bit taller to reserve space for the bar
tabsStrip.Size = UDim2.new(1, 0, 0, TABS_H + SCROLLBAR_GAP)

-- Add bottom padding so content doesn't touch the bar
tabsPad.PaddingBottom = UDim.new(0, SCROLLBAR_GAP)

-- Optional: a tiny top pad to center visually
tabsPad.PaddingTop = UDim.new(0, 2)

local tabsLayout = Instance.new("UIListLayout", tabsStrip)
tabsLayout.FillDirection = Enum.FillDirection.Horizontal
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left -- left, because we can scroll
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
tabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
tabsLayout.Padding = UDim.new(0, TAB_GAP)

-- Forward declarations to satisfy analyzers and allow cross-references
local tabList -- list of tab buttons (filled later)
local pageList -- list of pages (filled later)
local currentIndex -- active tab index (set later)

local function makeTab(label, order)
	local b = Instance.new("TextButton")
	b.Name = label
	b.LayoutOrder = order
	b.Text = label
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = WHITE
	b.AutoButtonColor = false
	b.BackgroundColor3 = TAB
	b.BorderSizePixel = 0
	b.Size = UDim2.new(0, TAB_W, 0, 32)
	b.Parent = tabsStrip
	corner(b, 8)
	stroke(b, TAB_SEL, 1, 0.75)

	-- Per-tab underline indicator
	local underline = Instance.new("Frame")
	underline.Name = "Underline"
	underline.AnchorPoint = Vector2.new(0.5, 1)
	underline.Position = UDim2.new(0.5, 0, 1, 3)
	underline.Size = UDim2.new(0, 0, 0, 3)
	underline.BackgroundColor3 = WHITE
	underline.BorderSizePixel = 0
	underline.Parent = b
	local ug = Instance.new("UIGradient")
	ug.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, MAGENTA),
		ColorSequenceKeypoint.new(1, CYAN)
	}
	ug.Parent = underline
	corner(underline, 3)

	b.MouseEnter:Connect(function()
		tween(b, TweenInfo.new(0.15), {BackgroundColor3 = TAB_SEL})
		-- Spawn small sparkles on hover
		for i = 1, 3 do
			local spark = Instance.new("Frame")
			spark.AnchorPoint = Vector2.new(0.5, 0.5)
			spark.Position = UDim2.fromScale(math.random() * 0.8 + 0.1, 0.5)
			spark.Size = UDim2.fromOffset(4, 4)
			spark.BackgroundColor3 = i % 2 == 0 and CYAN or MAGENTA
			spark.BackgroundTransparency = 0.3
			spark.BorderSizePixel = 0
			spark.ZIndex = 10
			spark.Parent = b
			corner(spark, 4)
			
			local t = tween(spark, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
				{Position = UDim2.new(spark.Position.X.Scale, 0, -0.5, 0), 
				 BackgroundTransparency = 1, 
				 Size = UDim2.fromOffset(0, 0)})
			t.Completed:Connect(function() spark:Destroy() end)
		end
	end)
	b.MouseLeave:Connect(function()
		if tabList[currentIndex] ~= b then
			tween(b, TweenInfo.new(0.15), {BackgroundColor3 = TAB})
		end
	end)

	return b
end

local tabItems = makeTab("Items", 1)
local tabAmmo  = makeTab("Ammo",  2)
local tabMisc  = makeTab("Misc",  3)
local tabShop  = makeTab("Shop",  4)

-- Tabs (add two more)
local tabCrates = makeTab("Crates", 5)
local tabTrash  = makeTab("Trash",  6)
local tabMods   = makeTab("Mods",   7)

tabList  = {tabItems, tabAmmo, tabMisc, tabShop, tabCrates, tabTrash, tabMods}

----------------------------------------------------------------------
-- Content area fills remaining space
----------------------------------------------------------------------
local contentTop = TITLE_H + GAP + TABS_H + GAP
local pages = Instance.new("Frame")
pages.Name = "Pages"
pages.BackgroundColor3 = Color3.fromRGB(30, 12, 40)
pages.BackgroundTransparency = 0.05
pages.Position = UDim2.new(0, 0, 0, contentTop)
pages.Size = UDim2.new(1, 0, 1, -contentTop)
pages.ClipsDescendants = true
pages.Parent = container
corner(pages, 10)
stroke(pages, Color3.fromRGB(210,120,255), 1, 0.6)

-- Multi-layer gradient effect
local pagesGrad = Instance.new("UIGradient")
pagesGrad.Rotation = 135
pagesGrad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0.00, Color3.fromRGB(60,28,80)),
	ColorSequenceKeypoint.new(0.30, Color3.fromRGB(48,20,62)),
	ColorSequenceKeypoint.new(0.70, Color3.fromRGB(38,16,50)),
	ColorSequenceKeypoint.new(1.00, Color3.fromRGB(28,10,38)),
}
pagesGrad.Parent = pages

-- Add subtle animated overlay
local pagesOverlay = Instance.new("Frame")
pagesOverlay.Name = "AnimatedOverlay"
pagesOverlay.BackgroundTransparency = 0.85
pagesOverlay.BorderSizePixel = 0
pagesOverlay.Size = UDim2.fromScale(1, 1)
pagesOverlay.ZIndex = 1
pagesOverlay.Parent = pages

local overlayGrad = Instance.new("UIGradient")
overlayGrad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0.0, MAGENTA),
	ColorSequenceKeypoint.new(0.5, CYAN),
	ColorSequenceKeypoint.new(1.0, MAGENTA)
}
overlayGrad.Rotation = 0
overlayGrad.Transparency = NumberSequence.new{
	NumberSequenceKeypoint.new(0, 1),
	NumberSequenceKeypoint.new(0.5, 0.85),
	NumberSequenceKeypoint.new(1, 1)
}
overlayGrad.Parent = pagesOverlay

-- Animate overlay gradient
task.spawn(function()
	while pages.Parent do
		tween(overlayGrad, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Rotation = 360})
		task.wait(4)
		overlayGrad.Rotation = 0
	end
end)

-- Ambient floating particles
local particlesContainer = Instance.new("Frame")
particlesContainer.Name = "Particles"
particlesContainer.BackgroundTransparency = 1
particlesContainer.BorderSizePixel = 0
particlesContainer.Size = UDim2.fromScale(1, 1)
particlesContainer.ZIndex = 1
particlesContainer.Parent = pages

-- Spawn ambient particles
task.spawn(function()
	local particles = {}
	for i = 1, 15 do
		local p = Instance.new("Frame")
		p.AnchorPoint = Vector2.new(0.5, 0.5)
		p.Position = UDim2.fromScale(math.random(), math.random())
		p.Size = UDim2.fromOffset(3, 3)
		p.BackgroundColor3 = math.random() > 0.5 and CYAN or MAGENTA
		p.BackgroundTransparency = 0.6
		p.BorderSizePixel = 0
		p.ZIndex = 2
		p.Parent = particlesContainer
		corner(p, 3)
		
		table.insert(particles, {
			frame = p,
			speedX = (math.random() - 0.5) * 0.15,
			speedY = (math.random() - 0.5) * 0.15,
			phase = math.random() * math.pi * 2
		})
	end
	
	-- Animate particles
	local time = 0
	RunService.RenderStepped:Connect(function(dt)
		if not pages.Parent then return end
		time = time + dt
		for _, particle in ipairs(particles) do
			local p = particle.frame
			local pos = p.Position
			local newX = pos.X.Scale + particle.speedX * dt
			local newY = pos.Y.Scale + particle.speedY * dt
			
			-- Wrap around edges
			if newX > 1.1 then newX = -0.1 elseif newX < -0.1 then newX = 1.1 end
			if newY > 1.1 then newY = -0.1 elseif newY < -0.1 then newY = 1.1 end
			
			p.Position = UDim2.fromScale(newX, newY)
			
			-- Pulsing transparency
			p.BackgroundTransparency = 0.4 + math.sin(time * 2 + particle.phase) * 0.3
		end
	end)
end)

-- Empty pages for tabs
local function makePage(name)
	local f = Instance.new("Frame")
	f.Name = name
	f.BackgroundTransparency = 1
	f.BorderSizePixel = 0
	f.Size = UDim2.new(1, 0, 1, 0)
	f.Visible = false
	f.Parent = pages
	return f
end
local pageItems = makePage("ItemsPage")
-- [Items UI] put right after: local pageItems = makePage("ItemsPage")

-- Top search bar
local itemsSearch = Instance.new("TextBox")
itemsSearch.Name = "ItemsSearch"
itemsSearch.Parent = pageItems
itemsSearch.ClearTextOnFocus = false
itemsSearch.PlaceholderText = "Search items..."
itemsSearch.Text = ""
itemsSearch.Font = Enum.Font.Gotham
itemsSearch.TextSize = 14
itemsSearch.TextColor3 = Color3.new(1,1,1)
itemsSearch.PlaceholderColor3 = Color3.fromRGB(200, 190, 220)
itemsSearch.BackgroundColor3 = Color3.fromRGB(66, 47, 88) -- ACCENT tone
itemsSearch.BorderSizePixel = 0
itemsSearch.Size = UDim2.new(1, -16, 0, 32)
itemsSearch.Position = UDim2.new(0, 8, 0, 8)
local itemsSearchCorner = Instance.new("UICorner", itemsSearch) itemsSearchCorner.CornerRadius = UDim.new(0, 8)

-- Scroll list (right-side vertical scrollbar)
local itemsList = Instance.new("ScrollingFrame")
itemsList.Name = "ItemsList"
itemsList.Parent = pageItems
itemsList.BackgroundTransparency = 1
itemsList.BorderSizePixel = 0
itemsList.ScrollBarThickness = 8
itemsList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- TAB_SEL tone
itemsList.ScrollingDirection = Enum.ScrollingDirection.Y
itemsList.AutomaticCanvasSize = Enum.AutomaticSize.Y
itemsList.Size = UDim2.new(1, -16, 1, -56) -- below search (32) + margins
itemsList.Position = UDim2.new(0, 8, 0, 48)

local pad = Instance.new("UIPadding", itemsList)
pad.PaddingTop = UDim.new(0, 8)
pad.PaddingLeft = UDim.new(0, 8)
pad.PaddingRight = UDim.new(0, 8)
pad.PaddingBottom = UDim.new(0, 8)

local itemsLayout = Instance.new("UIListLayout", itemsList)
itemsLayout.SortOrder = Enum.SortOrder.Name -- alphabetical by name by default
itemsLayout.Padding = UDim.new(0, 6)

-- Button factory (visuals match your theme)
local function makeItemButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) -- TAB
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local stroke = Instance.new("UIStroke", b)
	stroke.Color = Color3.fromRGB(170, 82, 205) -- TAB_SEL
	stroke.Thickness = 1
	stroke.Transparency = 0.6
	-- Hover glow
	b.MouseEnter:Connect(function()
		b.BackgroundColor3 = Color3.fromRGB(170, 82, 205)
		stroke.Transparency = 0.4
	end)
	b.MouseLeave:Connect(function()
		b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		stroke.Transparency = 0.6
	end)
	return b
end
-- [Items logic] live scan of Models, search, and teleport
do
	local itemsState = {
		modelButton = {},   -- [Model] = TextButton
		nameChanged = {},   -- [Model] = RBXScriptConnection
		observingRoot = nil, -- current root folder we watch
		rootConnections = {} -- to disconnect when root changes
	}

	-- Root getter (resolves path each time in case the hierarchy reloads)
	local function getLootRoot()
		local env = workspace:FindFirstChild("Environment")
		if not env then return nil end
		local wms = env:FindFirstChild("WorldModelSpawns")
		if not wms then return nil end
		local loot = wms:FindFirstChild("LootSpawnPoints")
		return loot
	end

	-- Teleport helper
	local function teleportToModel(m)
		if not m or not m:IsA("Model") then return end
		local char = player.Character or player.CharacterAdded:Wait()
		if not char then return end
		-- Prefer Pivot; fall back to PrimaryPart or part in model
		local pivotCFrame
		local ok, cf = pcall(function() return m:GetPivot() end)
		if ok then
			pivotCFrame = cf
		elseif m.PrimaryPart then
			pivotCFrame = m.PrimaryPart.CFrame
		else
			local part = m:FindFirstChildWhichIsA("BasePart", true)
			if part then pivotCFrame = part.CFrame end
		end
		if not pivotCFrame then return end

		local offset = CFrame.new(0, 4, 0) -- small lift above pivot
		-- Use Character:PivotTo for a clean teleport
		char:PivotTo(pivotCFrame * offset)
	end

	local function removeModel(m)
		local b = itemsState.modelButton[m]
		if b then b:Destroy() end
		itemsState.modelButton[m] = nil
		if itemsState.nameChanged[m] then itemsState.nameChanged[m]:Disconnect() itemsState.nameChanged[m] = nil end
	end

	local function addModel(m)
		if itemsState.modelButton[m] then return end
		local b = makeItemButton(m.Name)
		b.Parent = itemsList
		itemsState.modelButton[m] = b

		-- Click to TP
		b.MouseButton1Click:Connect(function()
			teleportToModel(m)
		end)

		-- Keep name in sync
		itemsState.nameChanged[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
			b.Name = m.Name
			b.Text = m.Name
		end)
	end

	-- Filter by search text (case-insensitive; hides/show buttons)
	local function applySearchFilter()
		local query = string.lower(itemsSearch.Text)
		for m, b in pairs(itemsState.modelButton) do
			if query == "" then
				b.Visible = true
			else
				b.Visible = string.find(string.lower(m.Name), query, 1, true) ~= nil
			end
		end
	end
	itemsSearch:GetPropertyChangedSignal("Text"):Connect(applySearchFilter)

	local function disconnectRootWatchers()
		for _, c in ipairs(itemsState.rootConnections) do
			if c then c:Disconnect() end
		end
		itemsState.rootConnections = {}
		itemsState.observingRoot = nil
	end

	local function populateAll(root)
		for m, _ in pairs(itemsState.modelButton) do removeModel(m) end
		if not root then return end
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("Model") then addModel(inst) end
		end
	end

	local function attachRootWatchers(root)
		disconnectRootWatchers()
		if not root then return end
		itemsState.observingRoot = root

		populateAll(root)
		applySearchFilter()

		table.insert(itemsState.rootConnections, root.DescendantAdded:Connect(function(inst)
			if inst:IsA("Model") then
				addModel(inst)
				applySearchFilter()
			end
		end))
		table.insert(itemsState.rootConnections, root.DescendantRemoving:Connect(function(inst)
			if inst:IsA("Model") then
				removeModel(inst)
			end
		end))

		table.insert(itemsState.rootConnections, root.AncestryChanged:Connect(function(_, parent)
			if not parent then
				task.defer(function()
					disconnectRootWatchers()
				end)
			end
		end))
	end

	task.spawn(function()
		local last
		while pageItems.Parent do
			local root = getLootRoot()
			if root ~= last then
				attachRootWatchers(root)
				last = root
			end
			task.wait(1.0)
		end
	end)
end
local pageAmmo  = makePage("AmmoPage")

-- [Ammo UI] put right after: local pageAmmo = makePage("AmmoPage")

local ammoList = Instance.new("ScrollingFrame")
ammoList.Name = "AmmoList"
ammoList.Parent = pageAmmo
ammoList.BackgroundTransparency = 1
ammoList.BorderSizePixel = 0
ammoList.AutomaticCanvasSize = Enum.AutomaticSize.Y
ammoList.ScrollingDirection = Enum.ScrollingDirection.Y
ammoList.ScrollBarThickness = 8
ammoList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- theme
ammoList.Size = UDim2.new(1, -16, 1, -16)
ammoList.Position = UDim2.new(0, 8, 0, 8)

local ammoPad = Instance.new("UIPadding", ammoList)
ammoPad.PaddingTop = UDim.new(0, 8)
ammoPad.PaddingLeft = UDim.new(0, 8)
ammoPad.PaddingRight = UDim.new(0, 8)
ammoPad.PaddingBottom = UDim.new(0, 8)

local ammoLayout = Instance.new("UIListLayout", ammoList)
ammoLayout.SortOrder = Enum.SortOrder.Name -- alphabetical by button name
ammoLayout.Padding = UDim.new(0, 6)

local function makeAmmoButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) -- tab color
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	-- style
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- [Ammo logic] MeshPart scan + live updates + teleport on click
do
	local ammoState = {
		meshButton = {},
		nameConn = {},
		rootConns = {},
		observedRoot = nil
	}

	local function getAmmoRoot()
		local env = workspace:FindFirstChild("Environment")
		if not env then return nil end
		local inter = env:FindFirstChild("Interactable")
		if not inter then return nil end
		return inter:FindFirstChild("Ammo")
	end

	local function teleportToPart(part: MeshPart)
		if not part or not part:IsA("BasePart") then return end
		local char = player.Character or player.CharacterAdded:Wait()
		if not char then return end
		char:PivotTo(part.CFrame * CFrame.new(0, 4, 0))
	end

	local function removeMesh(part: MeshPart)
		local b = ammoState.meshButton[part]
		if b then b:Destroy() end
		ammoState.meshButton[part] = nil
		if ammoState.nameConn[part] then ammoState.nameConn[part]:Disconnect() ammoState.nameConn[part] = nil end
	end

	local function addMesh(part: MeshPart)
		if ammoState.meshButton[part] then return end
		local b = makeAmmoButton(part.Name)
		b.Parent = ammoList
		ammoState.meshButton[part] = b

		b.MouseButton1Click:Connect(function()
			teleportToPart(part)
		end)

		ammoState.nameConn[part] = part:GetPropertyChangedSignal("Name"):Connect(function()
			b.Name = part.Name
			b.Text = part.Name
		end)
	end

	local function clearAll()
		for inst,_ in pairs(ammoState.meshButton) do removeMesh(inst) end
	end

	local function populateAll(root: Instance?)
		clearAll()
		if not root then return end
		for _, inst in ipairs(root:GetDescendants()) do
			if inst:IsA("MeshPart") then
				addMesh(inst)
			end
		end
	end

	local function disconnectRootWatchers()
		for _, c in ipairs(ammoState.rootConns) do
			if c then c:Disconnect() end
		end
		ammoState.rootConns = {}
		ammoState.observedRoot = nil
	end

	local function attachRootWatchers(root: Instance?)
		disconnectRootWatchers()
		if not root then return end
		ammoState.observedRoot = root

		populateAll(root)

		table.insert(ammoState.rootConns, root.DescendantAdded:Connect(function(inst)
			if inst:IsA("MeshPart") then addMesh(inst) end
		end))
		table.insert(ammoState.rootConns, root.DescendantRemoving:Connect(function(inst)
			if inst:IsA("MeshPart") then removeMesh(inst) end
		end))
		table.insert(ammoState.rootConns, root.AncestryChanged:Connect(function(_, parent)
			if not parent then disconnectRootWatchers() end
		end))
	end

	task.spawn(function()
		local last
		while pageAmmo.Parent do
			local root = getAmmoRoot()
			if root ~= last then
				attachRootWatchers(root)
				last = root
			end
			task.wait(1.0)
		end
	end)
end

local pageMisc  = makePage("MiscPage")
local pageMods  = makePage("ModsPage")

-- [Misc UI] Toggle row
local miscContainer = Instance.new("ScrollingFrame")
miscContainer.Name = "MiscContainer"
miscContainer.BackgroundTransparency = 1
miscContainer.BorderSizePixel = 0
miscContainer.Size = UDim2.new(1, -16, 1, -16)
miscContainer.Position = UDim2.new(0, 8, 0, 8)
miscContainer.ScrollingDirection = Enum.ScrollingDirection.Y
miscContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
miscContainer.ScrollBarThickness = 8
miscContainer.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
miscContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
miscContainer.Parent = pageMisc

local miscPad = Instance.new("UIPadding", miscContainer)
miscPad.PaddingTop = UDim.new(0, 8)
miscPad.PaddingLeft = UDim.new(0, 8)
miscPad.PaddingRight = UDim.new(0, 8)
miscPad.PaddingBottom = UDim.new(0, 8)

local miscLayout = Instance.new("UIListLayout", miscContainer)
miscLayout.SortOrder = Enum.SortOrder.LayoutOrder
miscLayout.Padding = UDim.new(0, 10)

-- [Mods UI] Toggle container
local modsContainer = Instance.new("ScrollingFrame")
modsContainer.Name = "ModsContainer"
modsContainer.BackgroundTransparency = 1
modsContainer.BorderSizePixel = 0
modsContainer.Size = UDim2.new(1, -16, 1, -16)
modsContainer.Position = UDim2.new(0, 8, 0, 8)
modsContainer.ScrollingDirection = Enum.ScrollingDirection.Y
modsContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
modsContainer.ScrollBarThickness = 8
modsContainer.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
modsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
modsContainer.Parent = pageMods

local modsPad = Instance.new("UIPadding", modsContainer)
modsPad.PaddingTop = UDim.new(0, 8)
modsPad.PaddingLeft = UDim.new(0, 8)
modsPad.PaddingRight = UDim.new(0, 8)
modsPad.PaddingBottom = UDim.new(0, 8)

local modsLayout = Instance.new("UIListLayout", modsContainer)
modsLayout.SortOrder = Enum.SortOrder.LayoutOrder
modsLayout.Padding = UDim.new(0, 10)

-- Group UI elements to reduce local variable count
local ui = {
	rows = {},
	labels = {},
	switches = {},
	knobs = {},
	corners = {},
	strokes = {}
}

-- Create UI elements using table structure
ui.rows.stamina = Instance.new("Frame")
ui.rows.stamina.BackgroundTransparency = 1
ui.rows.stamina.Size = UDim2.new(1, 0, 0, 36)
ui.rows.stamina.Parent = miscContainer

ui.labels.stamina = Instance.new("TextLabel")
ui.labels.stamina.BackgroundTransparency = 1
ui.labels.stamina.Text = "Infinite Stamina"
ui.labels.stamina.Font = Enum.Font.GothamBold
ui.labels.stamina.TextSize = 16
ui.labels.stamina.TextColor3 = Color3.new(1,1,1)
ui.labels.stamina.TextXAlignment = Enum.TextXAlignment.Left
ui.labels.stamina.Size = UDim2.new(1, -120, 1, 0)
ui.labels.stamina.Parent = ui.rows.stamina

ui.switches.stamina = Instance.new("TextButton")
ui.switches.stamina.Name = "InfStaminaSwitch"
ui.switches.stamina.AutoButtonColor = false
ui.switches.stamina.Text = ""
ui.switches.stamina.AnchorPoint = Vector2.new(1, 0.5)
ui.switches.stamina.Position = UDim2.new(1, 0, 0.5, 0)
ui.switches.stamina.Size = UDim2.new(0, 64, 0, 28)
ui.switches.stamina.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
ui.switches.stamina.BorderSizePixel = 0
ui.switches.stamina.Parent = ui.rows.stamina
ui.corners.stamina = Instance.new("UICorner", ui.switches.stamina) 
ui.corners.stamina.CornerRadius = UDim.new(1, 0)
ui.strokes.stamina = Instance.new("UIStroke", ui.switches.stamina) 
ui.strokes.stamina.Color = Color3.fromRGB(170, 82, 205) 
ui.strokes.stamina.Transparency = 0.4

ui.knobs.stamina = Instance.new("Frame")
ui.knobs.stamina.Name = "Knob"
ui.knobs.stamina.AnchorPoint = Vector2.new(0, 0.5)
ui.knobs.stamina.Position = UDim2.new(0, 3, 0.5, 0)
ui.knobs.stamina.Size = UDim2.new(0, 24, 0, 24)
ui.knobs.stamina.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
ui.knobs.stamina.BorderSizePixel = 0
ui.knobs.stamina.Parent = ui.switches.stamina
ui.corners.staminaKnob = Instance.new("UICorner", ui.knobs.stamina) 
ui.corners.staminaKnob.CornerRadius = UDim.new(1, 0)

-- Create aliases for backward compatibility
local row, label, switch, knob = ui.rows.stamina, ui.labels.stamina, ui.switches.stamina, ui.knobs.stamina

-- Helper function to create toggle rows
local function createToggleRow(name, text, switchName, parentContainer)
	parentContainer = parentContainer or miscContainer -- default to miscContainer
	
	ui.rows[name] = Instance.new("Frame")
	ui.rows[name].BackgroundTransparency = 1
	ui.rows[name].Size = UDim2.new(1, 0, 0, 36)
	ui.rows[name].Parent = parentContainer

	ui.labels[name] = Instance.new("TextLabel")
	ui.labels[name].BackgroundTransparency = 1
	ui.labels[name].Text = text
	ui.labels[name].Font = Enum.Font.GothamBold
	ui.labels[name].TextSize = 16
	ui.labels[name].TextColor3 = Color3.new(1,1,1)
	ui.labels[name].TextXAlignment = Enum.TextXAlignment.Left
	ui.labels[name].Size = UDim2.new(1, -120, 1, 0)
	ui.labels[name].Parent = ui.rows[name]

	ui.switches[name] = Instance.new("TextButton")
	ui.switches[name].Name = switchName
	ui.switches[name].AutoButtonColor = false
	ui.switches[name].Text = ""
	ui.switches[name].AnchorPoint = Vector2.new(1, 0.5)
	ui.switches[name].Position = UDim2.new(1, 0, 0.5, 0)
	ui.switches[name].Size = UDim2.new(0, 64, 0, 28)
	ui.switches[name].BackgroundColor3 = Color3.fromRGB(66, 47, 88)
	ui.switches[name].BorderSizePixel = 0
	ui.switches[name].Parent = ui.rows[name]
	ui.corners[name] = Instance.new("UICorner", ui.switches[name]) 
	ui.corners[name].CornerRadius = UDim.new(1, 0)
	ui.strokes[name] = Instance.new("UIStroke", ui.switches[name]) 
	ui.strokes[name].Color = Color3.fromRGB(170, 82, 205) 
	ui.strokes[name].Transparency = 0.4

	ui.knobs[name] = Instance.new("Frame")
	ui.knobs[name].Name = "Knob"
	ui.knobs[name].AnchorPoint = Vector2.new(0, 0.5)
	ui.knobs[name].Position = UDim2.new(0, 3, 0.5, 0)
	ui.knobs[name].Size = UDim2.new(0, 24, 0, 24)
	ui.knobs[name].BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	ui.knobs[name].BorderSizePixel = 0
	ui.knobs[name].Parent = ui.switches[name]
	ui.corners[name .. "Knob"] = Instance.new("UICorner", ui.knobs[name]) 
	ui.corners[name .. "Knob"].CornerRadius = UDim.new(1, 0)
end

-- Create Misc toggle rows
createToggleRow("ragdoll", "No ragdoll (No Fall)", "NoRagdollSwitch")
createToggleRow("paralyze", "Paralyze all bots", "ParalyzeBotsSwitch")

-- Create Mods toggle rows (pass modsContainer as 4th parameter)
createToggleRow("recoil", "No recoil", "NoRecoilSwitch", modsContainer)
createToggleRow("silent", "Silent gun", "SilentGunSwitch", modsContainer)
createToggleRow("fast", "Fast bullet", "FastBulletSwitch", modsContainer)
createToggleRow("equip", "No equip CD", "NoEquipCDSwitch", modsContainer)
createToggleRow("auto", "Full auto", "FullAutoSwitch", modsContainer)
createToggleRow("fireRate", "Fast fire rate", "FastFireRateSwitch", modsContainer)
createToggleRow("range", "Bullet range", "BulletRangeSwitch", modsContainer)
createToggleRow("spread", "No spread", "NoSpreadSwitch", modsContainer)


-- Create aliases for backward compatibility
local rowRag, ragLabel, ragSwitch, ragKnob = ui.rows.ragdoll, ui.labels.ragdoll, ui.switches.ragdoll, ui.knobs.ragdoll
local parRow, parLabel, parSwitch, parKnob = ui.rows.paralyze, ui.labels.paralyze, ui.switches.paralyze, ui.knobs.paralyze
local recoilRow, recoilLabel, recoilSwitch, recoilKnob = ui.rows.recoil, ui.labels.recoil, ui.switches.recoil, ui.knobs.recoil
local silentRow, silentLabel, silentSwitch, silentKnob = ui.rows.silent, ui.labels.silent, ui.switches.silent, ui.knobs.silent
local fastRow, fastLabel, fastSwitch, fastKnob = ui.rows.fast, ui.labels.fast, ui.switches.fast, ui.knobs.fast
local equipRow, equipLabel, equipSwitch, equipKnob = ui.rows.equip, ui.labels.equip, ui.switches.equip, ui.knobs.equip
local autoRow, autoLabel, autoSwitch, autoKnob = ui.rows.auto, ui.labels.auto, ui.switches.auto, ui.knobs.auto
local fireRateRow, fireRateLabel, fireRateSwitch, fireRateKnob = ui.rows.fireRate, ui.labels.fireRate, ui.switches.fireRate, ui.knobs.fireRate
local rangeRow, rangeLabel, rangeSwitch, rangeKnob = ui.rows.range, ui.labels.range, ui.switches.range, ui.knobs.range
local spreadRow, spreadLabel, spreadSwitch, spreadKnob = ui.rows.spread, ui.labels.spread, ui.switches.spread, ui.knobs.spread

-- [Misc UI] Kill all bots button
local killBotsBtn = Instance.new("TextButton")
killBotsBtn.Name = "KillAllBotsButton"
killBotsBtn.Text = "Kill all bots"
killBotsBtn.AutoButtonColor = false
killBotsBtn.Font = Enum.Font.GothamBold
killBotsBtn.TextSize = 14
killBotsBtn.TextColor3 = Color3.new(1,1,1)
killBotsBtn.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
killBotsBtn.BorderSizePixel = 0
killBotsBtn.Size = UDim2.new(0, 220, 0, 32)
killBotsBtn.Parent = miscContainer
do
	local c = Instance.new("UICorner", killBotsBtn) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", killBotsBtn) s.Color = Color3.fromRGB(170, 82, 205) s.Transparency = 0.55
	killBotsBtn.MouseEnter:Connect(function() killBotsBtn.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.35 end)
	killBotsBtn.MouseLeave:Connect(function() killBotsBtn.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.55 end)
end

-- [Misc logic — SAFE Infinite Stamina toggle that won't break the UI]

local RunService = game:GetService("RunService")

-- UI helpers
local function setSwitchVisual(isOn: boolean)
	if isOn then
		switch.BackgroundColor3 = Color3.fromRGB(90, 220, 255) -- cyan when ON
		knob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		knob.BackgroundColor3 = Color3.fromRGB(255, 105, 230) -- magenta knob
	else
		switch.BackgroundColor3 = Color3.fromRGB(66, 47, 88) -- off
		knob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		knob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	end
end

-- Locate the aspect folders the movement/UI read
local function getAspectFolders()
	local char = player.Character or player.CharacterAdded:Wait()
	local config = char:FindFirstChildWhichIsA("Configuration")
	if not config then return end
	local aspects = config:FindFirstChild("ReplicatedAspects")
	if not aspects then return end
	return aspects:FindFirstChild("LocalStamina"), aspects:FindFirstChild("StaminaState")
end

-- Capture original values (so we can restore and keep the UI consistent)
local snapshot -- { lsMax, ssMax, lsThreshold, ssThreshold }
local function captureOriginalStamina()
	local ls, ss = getAspectFolders()
	if not ls and not ss then return end
	snapshot = snapshot or {}
	if ls then
		if snapshot.lsMax == nil then snapshot.lsMax = ls:GetAttribute("Max") end
		if snapshot.lsThreshold == nil then snapshot.lsThreshold = ls:GetAttribute("Threshold") end
	end
	if ss then
		if snapshot.ssMax == nil then snapshot.ssMax = ss:GetAttribute("Max") end
		if snapshot.ssThreshold == nil then snapshot.ssThreshold = ss:GetAttribute("Threshold") end
	end
end

-- Keep stamina full without changing Max or regen flags
local function pushInfiniteStamina()
	local ls, ss = getAspectFolders()
	if ls then
		local mx = ls:GetAttribute("Max") or 100
		if ls:GetAttribute("Current") ~= mx then ls:SetAttribute("Current", mx) end
		if ls:GetAttribute("AtThreshold") ~= false then ls:SetAttribute("AtThreshold", false) end
	end
	if ss then
		local mx = ss:GetAttribute("Max") or 100
		if ss:GetAttribute("Current") ~= mx then ss:SetAttribute("Current", mx) end
		if ss:GetAttribute("AtThreshold") ~= false then ss:SetAttribute("AtThreshold", false) end
	end
end

-- Restore and gently "nudge" Current so UI Change listeners re-evaluate
local function restoreOriginalStamina()
	local ls, ss = getAspectFolders()
	if snapshot then
		if ls and snapshot.lsMax then
			local cur = ls:GetAttribute("Current")
			local mx  = ls:GetAttribute("Max") or snapshot.lsMax
			-- Clamp any overshoot
			if typeof(cur) == "number" and cur > mx then ls:SetAttribute("Current", mx) end
			if snapshot.lsThreshold ~= nil then ls:SetAttribute("Threshold", snapshot.lsThreshold) end
		end
		if ss and snapshot.ssMax then
			local cur = ss:GetAttribute("Current")
			local mx  = ss:GetAttribute("Max") or snapshot.ssMax
			if typeof(cur) == "number" and cur > mx then ss:SetAttribute("Current", mx) end
			if snapshot.ssThreshold ~= nil then ss:SetAttribute("Threshold", snapshot.ssThreshold) end
		end
	end

	-- Nudge to force UI refresh even if numbers "look" the same
	task.defer(function()
		local ls2, ss2 = getAspectFolders()
		if ls2 then
			local c = ls2:GetAttribute("Current")
			if typeof(c) == "number" then
				ls2:SetAttribute("Current", math.max(0, c - 0.001))
				task.wait()
				ls2:SetAttribute("Current", c)
			end
		end
		if ss2 then
			local c = ss2:GetAttribute("Current")
			if typeof(c) == "number" then
				ss2:SetAttribute("Current", math.max(0, c - 0.001))
				task.wait()
				ss2:SetAttribute("Current", c)
			end
		end
	end)
end

-- Toggle state
local ATTR_NAME = "PT_InfiniteStamina"
local infEnabled = player:GetAttribute(ATTR_NAME) == true
local hbConn: RBXScriptConnection? = nil
local charConn: RBXScriptConnection? = nil

local function startInfLoop()
	if hbConn then hbConn:Disconnect() hbConn = nil end
	captureOriginalStamina()
	pushInfiniteStamina()
	hbConn = RunService.Heartbeat:Connect(pushInfiniteStamina)
	if charConn then charConn:Disconnect() end
	charConn = player.CharacterAdded:Connect(function()
		snapshot = nil    -- recapture per character
		task.wait(0.25)
		captureOriginalStamina()
		if infEnabled then pushInfiniteStamina() end
	end)
end

local function stopInfLoop()
	if hbConn then hbConn:Disconnect() hbConn = nil end
	if charConn then charConn:Disconnect() charConn = nil end
	restoreOriginalStamina()
end

local function setInfEnabled(on: boolean)
	infEnabled = on
	player:SetAttribute(ATTR_NAME, on)
	setSwitchVisual(on) -- uses your existing UI helper from the Misc toggle
	if on then startInfLoop() else stopInfLoop() end
end

-- Initialize from saved state and wire the toggle button "switch"
setInfEnabled(infEnabled or false)
switch.MouseButton1Click:Connect(function()
	setInfEnabled(not infEnabled)
end)

-- [Misc logic] No ragdoll toggle implementation
local CollectionService = game:GetService("CollectionService")
local RunService        = game:GetService("RunService")

-- Visuals for the pill switch
local function setRagSwitchVisual(isOn: boolean)
	if isOn then
		ragSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)  -- cyan ON
		ragKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		ragKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)   -- magenta knob
	else
		ragSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)    -- OFF
		ragKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		ragKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	end
end

-- Helpers
local function getCharHum()
	local char = player.Character or player.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid")
	return char, hum
end

local function disableRagdollConstraints(char)
	local rc = char:FindFirstChild("RagdollConstraints")
	if not rc then return end
	for _, inst in ipairs(rc:GetChildren()) do
		if inst:IsA("Constraint") then inst.Enabled = false end
	end
end

-- State + connections
local ATTR_NO_RAG = "PT_NoRagdoll"
local noRagEnabled = player:GetAttribute(ATTR_NO_RAG) == true

local humStateConn: RBXScriptConnection?
local rcChildConn:  RBXScriptConnection?
local tagAddedConn: RBXScriptConnection?
local charAddedConn: RBXScriptConnection?
local currentHum: Humanoid?
local hadRagdollTagThisChar = false

local ragHbConn: RBXScriptConnection? = nil

local function getStatStateAspect()
	local char = player.Character or player.CharacterAdded:Wait()
	local config = char:FindFirstChildWhichIsA("Configuration")
	if not config then return end
	local aspects = config:FindFirstChild("ReplicatedAspects")
	if not aspects then return end
	return aspects:FindFirstChild("StatState")
end

local function startNoRagdollFor(char, hum)
	currentHum = hum
	if not (char and hum) then return end

	-- Remember if game had tagged us; we can re-add on disable
	hadRagdollTagThisChar = CollectionService:HasTag(hum, "Ragdoll")
	if hadRagdollTagThisChar then
		CollectionService:RemoveTag(hum, "Ragdoll")
	end

	-- Prevent future Ragdoll tags on our humanoid
	if tagAddedConn then tagAddedConn:Disconnect() end
	tagAddedConn = CollectionService:GetInstanceAddedSignal("Ragdoll"):Connect(function(obj)
		if not noRagEnabled then return end
		if obj == hum then
			CollectionService:RemoveTag(hum, "Ragdoll")
		end
	end)

	-- Disable Physics state attempts (client-side)
	pcall(function() hum:SetStateEnabled(Enum.HumanoidStateType.Physics, false) end)

	if humStateConn then humStateConn:Disconnect() end
	humStateConn = hum.StateChanged:Connect(function(_, newState)
		if not noRagEnabled then return end
		if newState == Enum.HumanoidStateType.Physics and hum.Health > 0 then
			-- Immediately stand back up
			hum:ChangeState(Enum.HumanoidStateType.GettingUp)
		end
	end)

	-- Keep constraints disabled
	disableRagdollConstraints(char)
	local rc = char:FindFirstChild("RagdollConstraints")
	if rc then
		if rcChildConn then rcChildConn:Disconnect() end
		rcChildConn = rc.ChildAdded:Connect(function(inst)
			if not noRagEnabled then return end
			if inst:IsA("Constraint") then inst.Enabled = false end
		end)
	end

	if ragHbConn then ragHbConn:Disconnect() end
	ragHbConn = RunService.Heartbeat:Connect(function()
		local statState = getStatStateAspect()
		if not statState then return end
		-- Ensure the game's tracking attributes related to falling and ragdoll are constantly false
		-- This reliably bypasses fall damage calculation on landing.
		statState:SetAttribute("IsFalling", false)
		statState:SetAttribute("IsRagdolled", false)
		statState:SetAttribute("ForcedRagdoll", false)
	end)
end

local function stopNoRagdoll()
	-- Restore listeners/state
	if humStateConn then humStateConn:Disconnect() humStateConn = nil end
	if rcChildConn  then rcChildConn:Disconnect()  rcChildConn  = nil end
	if tagAddedConn then tagAddedConn:Disconnect() tagAddedConn = nil end

	if ragHbConn then ragHbConn:Disconnect() ragHbConn = nil end

	-- Ensure aspects revert to a neutral state just in case (setting to false is the neutral state)
	local statState = getStatStateAspect()
	if statState then
		statState:SetAttribute("IsFalling", false)
		statState:SetAttribute("IsRagdolled", false)
		statState:SetAttribute("ForcedRagdoll", false)
	end

	local hum = currentHum
	currentHum = nil
	if hum then
		pcall(function() hum:SetStateEnabled(Enum.HumanoidStateType.Physics, true) end)
		-- Optionally re-add tag if the character had it originally
		if hadRagdollTagThisChar then
			pcall(function() CollectionService:AddTag(hum, "Ragdoll") end)
		end
	end
	hadRagdollTagThisChar = false
end

local function setNoRagdollEnabled(on: boolean)
	noRagEnabled = on
	player:SetAttribute(ATTR_NO_RAG, on)
	setRagSwitchVisual(on)

	if on then
		local char, hum = getCharHum()
		startNoRagdollFor(char, hum)
		if charAddedConn then charAddedConn:Disconnect() end
		charAddedConn = player.CharacterAdded:Connect(function(newChar)
			-- Re-apply every respawn
			local newHum = newChar:WaitForChild("Humanoid", 5)
			if newHum then
				startNoRagdollFor(newChar, newHum)
			end
		end)
	else
		stopNoRagdoll()
		if charAddedConn then charAddedConn:Disconnect() charAddedConn = nil end
	end
end

-- Initialize and wire
setNoRagdollEnabled(noRagEnabled or false)
ragSwitch.MouseButton1Click:Connect(function()
	setNoRagdollEnabled(not noRagEnabled)
end)

-- [Misc logic] Kill all bots + Paralyze all bots
do
	-- Bot management module to reduce local variable count
	local function botsFolder()
		return workspace:FindFirstChild("Characters")
	end
	local function forEachBotHumanoid(cb)
		local folder = botsFolder()
		if not folder then return end
		for _, child in ipairs(folder:GetChildren()) do
			if child:IsA("Model") and child.Name == "Bot" then
				local hum = child:FindFirstChildOfClass("Humanoid")
				if hum then cb(child, hum) end
			end
		end
	end

	-- Kill all bots function
	local function killAllBots()
		forEachBotHumanoid(function(_, hum)
			pcall(function() hum.Health = 0 end)
		end)
	end
	killBotsBtn.MouseButton1Click:Connect(killAllBots)

	-- Paralyze system
	local function setParSwitchVisual(isOn)
		if isOn then
			parSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			parKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			parKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			parSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			parKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			parKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_PARALYZE = "PT_ParalyzeAllBots"
	local parEnabled = player:GetAttribute(ATTR_PARALYZE) == true
	local original = {}
	local childAddedConn, childRemovedConn

	local function applyParalyzeTo(hum)
		if not original[hum] then
			original[hum] = { speed = hum.WalkSpeed, wasSitting = hum.Sit }
		end
		pcall(function()
			hum.Sit = true
			hum.WalkSpeed = 0
		end)
	end

	local function revertParalyzeFrom(hum)
		local snap = original[hum]
		pcall(function()
			if snap then
				hum.WalkSpeed = typeof(snap.speed) == "number" and snap.speed or 16
				hum.Sit = snap.wasSitting and true or false
			else
				hum.WalkSpeed = 16
				hum.Sit = false
			end
		end)
		original[hum] = nil
	end

	local function startParalyze()
		forEachBotHumanoid(function(_, hum) applyParalyzeTo(hum) end)
		local folder = botsFolder()
		if not folder then return end

		if childAddedConn then childAddedConn:Disconnect() end
		if childRemovedConn then childRemovedConn:Disconnect() end

		childAddedConn = folder.ChildAdded:Connect(function(child)
			if not parEnabled then return end
			if child:IsA("Model") and child.Name == "Bot" then
				local hum = child:FindFirstChildOfClass("Humanoid")
				if hum then applyParalyzeTo(hum) end
			end
		end)

		childRemovedConn = folder.ChildRemoved:Connect(function(child)
			if child:IsA("Model") and child.Name == "Bot" then
				local hum = child:FindFirstChildOfClass("Humanoid")
				if hum and original[hum] then original[hum] = nil end
			end
		end)
	end

	local function stopParalyze()
		forEachBotHumanoid(function(_, hum) revertParalyzeFrom(hum) end)
		if childAddedConn then childAddedConn:Disconnect() childAddedConn = nil end
		if childRemovedConn then childRemovedConn:Disconnect() childRemovedConn = nil end
		original = {}
	end

	local function setParalyzeEnabled(on)
		parEnabled = on
		player:SetAttribute(ATTR_PARALYZE, on)
		setParSwitchVisual(on)
		if on then startParalyze() else stopParalyze() end
	end

	-- Initialize + wire
	setParalyzeEnabled(parEnabled or false)
	parSwitch.MouseButton1Click:Connect(function()
		setParalyzeEnabled(not parEnabled)
	end)

	player.CharacterAdded:Connect(function()
		if parEnabled then
			task.delay(0.25, startParalyze)
		end
	end)
end

-- [Misc logic] No recoil toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setRecoilSwitchVisual(isOn)
		if isOn then
			recoilSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			recoilKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			recoilKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			recoilSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			recoilKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			recoilKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_NO_RECOIL = "PT_NoRecoil"
	local noRecoilEnabled = player:GetAttribute(ATTR_NO_RECOIL) == true
	local originals = {} -- [module] = {RecoilPower = ..., AngleX_Min = ..., etc}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end

		local mods = {}

		-- Scan Firearms
		local firearms = settings:FindFirstChild("Firearms")
		if firearms then
			for _, cat in ipairs(firearms:GetDescendants()) do
				if cat:IsA("ModuleScript") then
					table.insert(mods, cat)
				end
			end
		end

		-- Scan Melee
		local melee = settings:FindFirstChild("Melee")
		if melee then
			for _, cat in ipairs(melee:GetDescendants()) do
				if cat:IsA("ModuleScript") then
					table.insert(mods, cat)
				end
			end
		end

		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			CameraRecoilingEnabled = data.CameraRecoilingEnabled,
			RecoilPower = data.RecoilPower or data.Recoil,
			AngleX_Min = data.AngleX_Min,
			AngleX_Max = data.AngleX_Max,
			AngleY_Min = data.AngleY_Min,
			AngleY_Max = data.AngleY_Max,
			AngleZ_Min = data.AngleZ_Min,
			AngleZ_Max = data.AngleZ_Max,
			RecoilSpeed = data.RecoilSpeed,
			RecoilDamper = data.RecoilDamper,
			RecoilRedutionAimingDown = data.RecoilRedutionAimingDown,
			RecoilRedution = data.RecoilRedution,
		}
	end

	local function applyNoRecoil(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.CameraRecoilingEnabled = false
			if data.RecoilPower then data.RecoilPower = 0 end
			if data.Recoil then data.Recoil = 0 end
			data.AngleX_Min = 0
			data.AngleX_Max = 0
			data.AngleY_Min = 0
			data.AngleY_Max = 0
			data.AngleZ_Min = 0
			data.AngleZ_Max = 0
			if data.RecoilSpeed then data.RecoilSpeed = 0 end
			if data.RecoilDamper then data.RecoilDamper = 0 end
			if data.RecoilRedutionAimingDown then data.RecoilRedutionAimingDown = 1 end
			if data.RecoilRedution then data.RecoilRedution = 1 end
		end)
	end

	local function restoreRecoil(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.CameraRecoilingEnabled ~= nil then data.CameraRecoilingEnabled = snap.CameraRecoilingEnabled end
			if snap.RecoilPower ~= nil then 
				if data.RecoilPower then data.RecoilPower = snap.RecoilPower end
				if data.Recoil then data.Recoil = snap.RecoilPower end
			end
			if snap.AngleX_Min ~= nil then data.AngleX_Min = snap.AngleX_Min end
			if snap.AngleX_Max ~= nil then data.AngleX_Max = snap.AngleX_Max end
			if snap.AngleY_Min ~= nil then data.AngleY_Min = snap.AngleY_Min end
			if snap.AngleY_Max ~= nil then data.AngleY_Max = snap.AngleY_Max end
			if snap.AngleZ_Min ~= nil then data.AngleZ_Min = snap.AngleZ_Min end
			if snap.AngleZ_Max ~= nil then data.AngleZ_Max = snap.AngleZ_Max end
			if snap.RecoilSpeed ~= nil then data.RecoilSpeed = snap.RecoilSpeed end
			if snap.RecoilDamper ~= nil then data.RecoilDamper = snap.RecoilDamper end
			if snap.RecoilRedutionAimingDown ~= nil then data.RecoilRedutionAimingDown = snap.RecoilRedutionAimingDown end
			if snap.RecoilRedution ~= nil then data.RecoilRedution = snap.RecoilRedution end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if noRecoilEnabled then
				applyNoRecoil(mod)
			else
				restoreRecoil(mod)
			end
		end
	end

	local function setNoRecoilEnabled(on)
		noRecoilEnabled = on
		player:SetAttribute(ATTR_NO_RECOIL, on)
		setRecoilSwitchVisual(on)
		applyToAll()
	end

	setNoRecoilEnabled(noRecoilEnabled or false)
	recoilSwitch.MouseButton1Click:Connect(function()
		setNoRecoilEnabled(not noRecoilEnabled)
	end)
end

-- [Misc logic] Silent gun toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setSilentSwitchVisual(isOn)
		if isOn then
			silentSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			silentKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			silentKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			silentSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			silentKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			silentKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_SILENT = "PT_SilentGun"
	local silentEnabled = player:GetAttribute(ATTR_SILENT) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			Silenced = data.Silenced,
		}
	end

	local function applySilent(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.Silenced = true
		end)
	end

	local function restoreSilent(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.Silenced ~= nil then data.Silenced = snap.Silenced end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if silentEnabled then
				applySilent(mod)
			else
				restoreSilent(mod)
			end
		end
	end

	local function setSilentEnabled(on)
		silentEnabled = on
		player:SetAttribute(ATTR_SILENT, on)
		setSilentSwitchVisual(on)
		applyToAll()
	end

	setSilentEnabled(silentEnabled or false)
silentSwitch.MouseButton1Click:Connect(function()
	setSilentEnabled(not silentEnabled)
end)
end

-- [Misc logic] Fast bullet toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setFastSwitchVisual(isOn)
		if isOn then
			fastSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			fastKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			fastKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			fastSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			fastKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			fastKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_FAST = "PT_FastBullet"
	local fastEnabled = player:GetAttribute(ATTR_FAST) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			ProjectileSpeed = data.ProjectileSpeed,
		}
	end

	local function applyFast(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.ProjectileSpeed = 10000
		end)
	end

	local function restoreFast(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.ProjectileSpeed ~= nil then data.ProjectileSpeed = snap.ProjectileSpeed end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if fastEnabled then
				applyFast(mod)
			else
				restoreFast(mod)
			end
		end
	end

	local function setFastEnabled(on)
		fastEnabled = on
		player:SetAttribute(ATTR_FAST, on)
		setFastSwitchVisual(on)
		applyToAll()
	end

	setFastEnabled(fastEnabled or false)
fastSwitch.MouseButton1Click:Connect(function()
	setFastEnabled(not fastEnabled)
	end)
end

-- [Misc logic] No equip CD toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setEquipSwitchVisual(isOn)
		if isOn then
			equipSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			equipKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			equipKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			equipSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			equipKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			equipKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_NO_EQUIP = "PT_NoEquipCD"
	local noEquipEnabled = player:GetAttribute(ATTR_NO_EQUIP) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			EquipCooldown = data.EquipCooldown,
		}
	end

	local function applyNoEquip(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.EquipCooldown = 0
		end)
	end

	local function restoreEquip(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.EquipCooldown ~= nil then data.EquipCooldown = snap.EquipCooldown end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if noEquipEnabled then
				applyNoEquip(mod)
			else
				restoreEquip(mod)
			end
		end
	end

	local function setNoEquipEnabled(on)
		noEquipEnabled = on
		player:SetAttribute(ATTR_NO_EQUIP, on)
		setEquipSwitchVisual(on)
		applyToAll()
	end

	setNoEquipEnabled(noEquipEnabled or false)
	equipSwitch.MouseButton1Click:Connect(function()
		setNoEquipEnabled(not noEquipEnabled)
	end)
end

-- [Misc logic] Full auto toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setAutoSwitchVisual(isOn)
		if isOn then
			autoSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			autoKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			autoKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			autoSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			autoKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			autoKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_FULL_AUTO = "PT_FullAuto"
	local fullAutoEnabled = player:GetAttribute(ATTR_FULL_AUTO) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			FullAutoFire = data.FullAutoFire,
		}
	end

	local function applyFullAuto(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.FullAutoFire = true
		end)
	end

	local function restoreFullAuto(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.FullAutoFire ~= nil then data.FullAutoFire = snap.FullAutoFire end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if fullAutoEnabled then
				applyFullAuto(mod)
			else
				restoreFullAuto(mod)
			end
		end
	end

	local function setFullAutoEnabled(on)
		fullAutoEnabled = on
		player:SetAttribute(ATTR_FULL_AUTO, on)
		setAutoSwitchVisual(on)
		applyToAll()
	end

	setFullAutoEnabled(fullAutoEnabled or false)
	autoSwitch.MouseButton1Click:Connect(function()
		setFullAutoEnabled(not fullAutoEnabled)
	end)
end

-- [Misc logic] Fast fire rate toggle (Firearms + Melee)
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setFireRateSwitchVisual(isOn)
		if isOn then
			fireRateSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			fireRateKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			fireRateKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			fireRateSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			fireRateKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			fireRateKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_FAST_FIRE = "PT_FastFireRate"
	local fastFireEnabled = player:GetAttribute(ATTR_FAST_FIRE) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			FireDelay = data.FireDelay,
		}
	end

	local function applyFastFire(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.FireDelay = 0
		end)
	end

	local function restoreFire(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.FireDelay ~= nil then data.FireDelay = snap.FireDelay end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if fastFireEnabled then
				applyFastFire(mod)
			else
				restoreFire(mod)
			end
		end
	end

	local function setFastFireEnabled(on)
		fastFireEnabled = on
		player:SetAttribute(ATTR_FAST_FIRE, on)
		setFireRateSwitchVisual(on)
		applyToAll()
	end

	setFastFireEnabled(fastFireEnabled or false)
	fireRateSwitch.MouseButton1Click:Connect(function()
		setFastFireEnabled(not fastFireEnabled)
	end)
end


-- [Misc logic] Bullet range toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setRangeSwitchVisual(isOn)
		if isOn then
			rangeSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			rangeKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			rangeKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			rangeSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			rangeKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			rangeKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_RANGE = "PT_BulletRange"
	local rangeEnabled = player:GetAttribute(ATTR_RANGE) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			ProjectileMaxDist = data.ProjectileMaxDist,
		}
	end

	local function applyRange(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.ProjectileMaxDist = 99999
		end)
	end

	local function restoreRange(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.ProjectileMaxDist ~= nil then data.ProjectileMaxDist = snap.ProjectileMaxDist end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if rangeEnabled then
				applyRange(mod)
			else
				restoreRange(mod)
			end
		end
	end

	local function setRangeEnabled(on)
		rangeEnabled = on
		player:SetAttribute(ATTR_RANGE, on)
		setRangeSwitchVisual(on)
		applyToAll()
	end

	setRangeEnabled(rangeEnabled or false)
	rangeSwitch.MouseButton1Click:Connect(function()
		setRangeEnabled(not rangeEnabled)
	end)
end

-- [Misc logic] No spread toggle
do
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local function setSpreadSwitchVisual(isOn)
		if isOn then
			spreadSwitch.BackgroundColor3 = Color3.fromRGB(90, 220, 255)
			spreadKnob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			spreadKnob.BackgroundColor3 = Color3.fromRGB(255, 105, 230)
		else
			spreadSwitch.BackgroundColor3 = Color3.fromRGB(66, 47, 88)
			spreadKnob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
			spreadKnob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		end
	end

	local ATTR_NO_SPREAD = "PT_NoSpread"
	local noSpreadEnabled = player:GetAttribute(ATTR_NO_SPREAD) == true
	local originals = {}

	local function getWeaponModules()
		local assets = ReplicatedStorage:FindFirstChild("Assets")
		if not assets then return {} end
		local shared = assets:FindFirstChild("SharedData")
		if not shared then return {} end
		local settings = shared:FindFirstChild("WeaponSettings")
		if not settings then return {} end
		local firearms = settings:FindFirstChild("Firearms")
		if not firearms then return {} end
		
		local mods = {}
		for _, cat in ipairs(firearms:GetDescendants()) do
			if cat:IsA("ModuleScript") then
				table.insert(mods, cat)
			end
		end
		return mods
	end

	local function captureOriginal(mod)
		if originals[mod] then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		originals[mod] = {
			MinSpreadAngle = data.MinSpreadAngle,
			MaxSpreadAngle = data.MaxSpreadAngle,
			ProjectileGravity = data.ProjectileGravity,
		}
	end

	local function applyNoSpread(mod)
		captureOriginal(mod)
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			data.MinSpreadAngle = 0
			data.MaxSpreadAngle = 0
			data.ProjectileGravity = Vector3.new(0, 0, 0)
		end)
	end

	local function restoreSpread(mod)
		local snap = originals[mod]
		if not snap then return end
		local ok, data = pcall(function() return require(mod) end)
		if not ok or type(data) ~= "table" then return end
		pcall(function()
			if snap.MinSpreadAngle ~= nil then data.MinSpreadAngle = snap.MinSpreadAngle end
			if snap.MaxSpreadAngle ~= nil then data.MaxSpreadAngle = snap.MaxSpreadAngle end
			if snap.ProjectileGravity ~= nil then data.ProjectileGravity = snap.ProjectileGravity end
		end)
	end

	local function applyToAll()
		for _, mod in ipairs(getWeaponModules()) do
			if noSpreadEnabled then
				applyNoSpread(mod)
			else
				restoreSpread(mod)
			end
		end
	end

	local function setNoSpreadEnabled(on)
		noSpreadEnabled = on
		player:SetAttribute(ATTR_NO_SPREAD, on)
		setSpreadSwitchVisual(on)
		applyToAll()
	end

	setNoSpreadEnabled(noSpreadEnabled or false)
	spreadSwitch.MouseButton1Click:Connect(function()
		setNoSpreadEnabled(not noSpreadEnabled)
	end)
end

-- (No reload feature removed)

local pageShop  = makePage("ShopPage")
local pageCrates = makePage("CratesPage")
local pageTrash  = makePage("TrashPage")

-- [Trash UI]
local trashList = Instance.new("ScrollingFrame")
trashList.Name = "TrashList"
trashList.Parent = pageTrash
trashList.BackgroundTransparency = 1
trashList.BorderSizePixel = 0
trashList.AutomaticCanvasSize = Enum.AutomaticSize.Y
trashList.ScrollingDirection = Enum.ScrollingDirection.Y
trashList.ScrollBarThickness = 8
trashList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
trashList.Size = UDim2.new(1, -16, 1, -16)
trashList.Position = UDim2.new(0, 8, 0, 8)

local trashPad = Instance.new("UIPadding", trashList)
trashPad.PaddingTop = UDim.new(0, 8)
trashPad.PaddingLeft = UDim.new(0, 8)
trashPad.PaddingRight = UDim.new(0, 8)
trashPad.PaddingBottom = UDim.new(0, 8)

local trashLayout = Instance.new("UIListLayout", trashList)
trashLayout.SortOrder = Enum.SortOrder.Name
trashLayout.Padding = UDim.new(0, 6)

local function makeTrashButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- Encapsulated Trash logic
local function setupTrashLogic()
    local state = {
        buttons = {},
        nameConn = {},
        rootConns = {},
        observedRoot = nil
    }

    local function getHazardsRoot()
        local env = workspace:FindFirstChild("Environment")
        if not env then return nil end
        local inter = env:FindFirstChild("Interactable")
        if not inter then return nil end
        return inter:FindFirstChild("Hazards")
    end

    local function tpToModelTrash(m)
        if not m or not m:IsA("Model") then return end
        local char = player.Character or player.CharacterAdded:Wait()
        if not char then return end
        local cf
        local ok, pivot = pcall(function() return m:GetPivot() end)
        if ok then cf = pivot
        elseif m.PrimaryPart then cf = m.PrimaryPart.CFrame
        else
            local p = m:FindFirstChildWhichIsA("BasePart", true)
            if p then cf = p.CFrame end
        end
        if not cf then return end
        char:PivotTo(cf * CFrame.new(0, 4, 0))
    end

    local function removeTrashModel(m)
        local b = state.buttons[m]
        if b then b:Destroy() end
        state.buttons[m] = nil
        if state.nameConn[m] then state.nameConn[m]:Disconnect() state.nameConn[m] = nil end
    end

    local function addTrashModel(m)
        if not (m and m:IsA("Model") and m.Name == "Trash Can") then return end
        if state.buttons[m] then return end
        local b = makeTrashButton(m.Name)
        b.Parent = trashList
        state.buttons[m] = b
        b.MouseButton1Click:Connect(function() tpToModelTrash(m) end)
        state.nameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
            if m.Name ~= "Trash Can" then
                removeTrashModel(m)
            else
                local btn = state.buttons[m]
                if btn then btn.Name = m.Name; btn.Text = m.Name end
            end
        end)
    end

    local function clearTrash()
        for m,_ in pairs(state.buttons) do removeTrashModel(m) end
    end

    local function populateTrashDirect(root)
        clearTrash()
        if not root then return end
        for _, child in ipairs(root:GetChildren()) do
            addTrashModel(child)
        end
    end

    local function disconnectHazardsWatch()
        for _, c in ipairs(state.rootConns) do if c then c:Disconnect() end end
        state.rootConns = {}
        state.observedRoot = nil
    end

    local function attachHazardsWatch(root)
        disconnectHazardsWatch()
        if not root then return end
        state.observedRoot = root
        populateTrashDirect(root)
        table.insert(state.rootConns, root.ChildAdded:Connect(addTrashModel))
        table.insert(state.rootConns, root.ChildRemoved:Connect(function(inst)
            if state.buttons[inst] then removeTrashModel(inst) end
        end))
        table.insert(state.rootConns, root.AncestryChanged:Connect(function(_, parent)
            if not parent then disconnectHazardsWatch() end
        end))
    end

    task.spawn(function()
        local last
        while pageTrash.Parent do
            local root = getHazardsRoot()
            if root ~= last then
                attachHazardsWatch(root)
                last = root
            end
            task.wait(1.0)
        end
    end)
end

setupTrashLogic()

-- [Crates UI]
local cratesList = Instance.new("ScrollingFrame")
cratesList.Name = "CratesList"
cratesList.Parent = pageCrates
cratesList.BackgroundTransparency = 1
cratesList.BorderSizePixel = 0
cratesList.AutomaticCanvasSize = Enum.AutomaticSize.Y
cratesList.ScrollingDirection = Enum.ScrollingDirection.Y
cratesList.ScrollBarThickness = 8
cratesList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
cratesList.Size = UDim2.new(1, -16, 1, -16)
cratesList.Position = UDim2.new(0, 8, 0, 8)

local cratesPad = Instance.new("UIPadding", cratesList)
cratesPad.PaddingTop = UDim.new(0, 8)
cratesPad.PaddingLeft = UDim.new(0, 8)
cratesPad.PaddingRight = UDim.new(0, 8)
cratesPad.PaddingBottom = UDim.new(0, 8)

local cratesLayout = Instance.new("UIListLayout", cratesList)
cratesLayout.SortOrder = Enum.SortOrder.Name
cratesLayout.Padding = UDim.new(0, 6)

local function makeCrateButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- Encapsulated Crates logic
local function setupCratesLogic()
    local state = {
        buttons = {},
        nameConn = {},
        rootConns = {}
    }

    local function tpToModelCrate(m)
        if not m or not m:IsA("Model") then return end
        local char = player.Character or player.CharacterAdded:Wait()
        if not char then return end
        local cf
        local ok, pivot = pcall(function() return m:GetPivot() end)
        if ok then cf = pivot
        elseif m.PrimaryPart then cf = m.PrimaryPart.CFrame
        else
            local p = m:FindFirstChildWhichIsA("BasePart", true)
            if p then cf = p.CFrame end
        end
        if not cf then return end
        char:PivotTo(cf * CFrame.new(0, 4, 0))
    end

    local function removeCrate(m)
        local b = state.buttons[m]
        if b then b:Destroy() end
        state.buttons[m] = nil
        if state.nameConn[m] then state.nameConn[m]:Disconnect() state.nameConn[m] = nil end
    end

    local function addCrate(m)
        if not (m and m:IsA("Model") and m.Name == "Military Crate") then return end
        if state.buttons[m] then return end
        local b = makeCrateButton(m.Name)
        b.Parent = cratesList
        state.buttons[m] = b
        b.MouseButton1Click:Connect(function() tpToModelCrate(m) end)
        state.nameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
            if m.Name ~= "Military Crate" then
                removeCrate(m)
            else
                local btn = state.buttons[m]
                if btn then btn.Name = m.Name; btn.Text = m.Name end
            end
        end)
    end

    local function clearCrates()
        for m,_ in pairs(state.buttons) do removeCrate(m) end
    end

    local function populateCratesAll()
        clearCrates()
        for _, inst in ipairs(workspace:GetDescendants()) do
            addCrate(inst)
        end
    end

    local function disconnectCrateWatchers()
        for _, c in ipairs(state.rootConns) do if c then c:Disconnect() end end
        state.rootConns = {}
    end

    local function attachCrateWatchers()
        disconnectCrateWatchers()
        populateCratesAll()
        table.insert(state.rootConns, workspace.DescendantAdded:Connect(addCrate))
        table.insert(state.rootConns, workspace.DescendantRemoving:Connect(function(inst)
            if state.buttons[inst] then removeCrate(inst) end
        end))
        -- Light poll for renames
        task.spawn(function()
            while pageCrates.Parent do
                for _, inst in ipairs(workspace:GetDescendants()) do
                    if inst:IsA("Model") and inst.Name == "Military Crate" and not state.buttons[inst] then
                        addCrate(inst)
                    end
                end
                task.wait(2.0)
            end
        end)
    end

    attachCrateWatchers()
end

setupCratesLogic()

-- [Shop UI] simple vertical list
local shopList = Instance.new("ScrollingFrame")
shopList.Name = "ShopList"
shopList.Parent = pageShop
shopList.BackgroundTransparency = 1
shopList.BorderSizePixel = 0
shopList.AutomaticCanvasSize = Enum.AutomaticSize.Y
shopList.ScrollingDirection = Enum.ScrollingDirection.Y
shopList.ScrollBarThickness = 8
shopList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
shopList.Size = UDim2.new(1, -16, 1, -16)
shopList.Position = UDim2.new(0, 8, 0, 8)

local shopPad = Instance.new("UIPadding", shopList)
shopPad.PaddingTop = UDim.new(0, 8)
shopPad.PaddingLeft = UDim.new(0, 8)
shopPad.PaddingRight = UDim.new(0, 8)
shopPad.PaddingBottom = UDim.new(0, 8)

local shopLayout = Instance.new("UIListLayout", shopList)
shopLayout.SortOrder = Enum.SortOrder.Name
shopLayout.Padding = UDim.new(0, 6)

local function makeShopButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- Encapsulated Shop logic
local function setupShopLogic()
        local state = {
            buttons = {},
            nameConn = {},
            rootConns = {},
            observedRoot = nil
        }

        local function getVendorsRoot()
            local env = workspace:FindFirstChild("Environment")
            if not env then return nil end
            return env:FindFirstChild("Vendors")
        end

        local function tpToModel(m)
            if not m or not m:IsA("Model") then return end
            local char = player.Character or player.CharacterAdded:Wait()
            if not char then return end
            local cf
            local ok, pivot = pcall(function() return m:GetPivot() end)
            if ok then cf = pivot
            elseif m.PrimaryPart then cf = m.PrimaryPart.CFrame
            else
                local p = m:FindFirstChildWhichIsA("BasePart", true)
                if p then cf = p.CFrame end
            end
            if not cf then return end
            char:PivotTo(cf * CFrame.new(0, 4, 0))
        end

        local function removeVendorModel(m)
            local b = state.buttons[m]
            if b then b:Destroy() end
            state.buttons[m] = nil
            if state.nameConn[m] then state.nameConn[m]:Disconnect() state.nameConn[m] = nil end
        end

        local function addVendorModel(m)
            if state.buttons[m] then return end
            local b = makeShopButton(m.Name)
            b.Parent = shopList
            state.buttons[m] = b
            b.MouseButton1Click:Connect(function() tpToModel(m) end)
            state.nameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
                b.Name = m.Name
                b.Text = m.Name
            end)
        end

        local function clearVendors()
            for m,_ in pairs(state.buttons) do removeVendorModel(m) end
        end

        local function populateVendors(root)
            clearVendors()
            if not root then return end
            for _, child in ipairs(root:GetChildren()) do
                if child:IsA("Model") then
                    addVendorModel(child)
                end
            end
        end

        local function disconnectVendorsWatch()
            for _, c in ipairs(state.rootConns) do if c then c:Disconnect() end end
            state.rootConns = {}
            state.observedRoot = nil
        end

        local function attachVendorsWatch(root)
            disconnectVendorsWatch()
            if not root then return end
            state.observedRoot = root
            populateVendors(root)
            table.insert(state.rootConns, root.ChildAdded:Connect(function(inst)
                if inst:IsA("Model") then addVendorModel(inst) end
            end))
            table.insert(state.rootConns, root.ChildRemoved:Connect(function(inst)
                if state.buttons[inst] then removeVendorModel(inst) end
            end))
        end

        task.spawn(function()
            local last
            while pageShop.Parent do
                local root = getVendorsRoot()
                if root ~= last then
                    attachVendorsWatch(root)
                    last = root
                end
                task.wait(1.0)
            end
        end)
    end

    setupShopLogic()

    -- Replace your existing tabList/pageList with these:
    pageList  = {pageItems, pageAmmo, pageMisc, pageShop, pageCrates, pageTrash, pageMods}

    -- Initial selection
    currentIndex = 1
    pageList[currentIndex].Visible = true
    pageList[currentIndex].Position = UDim2.new(0,0,0,0)

-- Update tab visuals (color + underline)
local function setTabVisual(activeIndex)
	for i, b in ipairs(tabList) do
		local isActive = (i == activeIndex)
		local bg = isActive and TAB_SEL or TAB
		tween(b, TweenInfo.new(0.15), {BackgroundColor3 = bg})
		local u = b:FindFirstChild("Underline")
		if u then
			if isActive then
				tween(u, TweenInfo.new(0.20, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 3)})
			else
				tween(u, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 0, 0, 3)})
			end
		end
	end
	tween(win, TweenInfo.new(0.2), {BackgroundColor3 = BG})
end
setTabVisual(currentIndex)

-- Directional swipe transition with particles
local function slideTo(targetIndex)
	if targetIndex == currentIndex then
		setTabVisual(currentIndex)
		return
	end
	
	-- Spawn transition particles
	task.spawn(function()
		local particleContainer = Instance.new("Frame")
		particleContainer.Name = "TransitionParticles"
		particleContainer.BackgroundTransparency = 1
		particleContainer.BorderSizePixel = 0
		particleContainer.Size = UDim2.fromScale(1, 1)
		particleContainer.ZIndex = 50
		particleContainer.Parent = pages
		
		for i = 1, 12 do
			local particle = Instance.new("Frame")
			particle.AnchorPoint = Vector2.new(0.5, 0.5)
			particle.Position = UDim2.fromScale(math.random(), math.random())
			particle.Size = UDim2.fromOffset(8, 8)
			particle.BackgroundColor3 = i % 2 == 0 and CYAN or MAGENTA
			particle.BackgroundTransparency = 0.4
			particle.BorderSizePixel = 0
			particle.Parent = particleContainer
			corner(particle, 8)
			
			-- Glow
			local glow = Instance.new("Frame")
			glow.AnchorPoint = Vector2.new(0.5, 0.5)
			glow.Position = UDim2.fromScale(0.5, 0.5)
			glow.Size = UDim2.fromOffset(16, 16)
			glow.BackgroundColor3 = particle.BackgroundColor3
			glow.BackgroundTransparency = 0.75
			glow.BorderSizePixel = 0
			glow.Parent = particle
			corner(glow, 16)
			
			-- Random motion
			local endX = math.random()
			local endY = math.random()
			tween(particle, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
				{Position = UDim2.fromScale(endX, endY), BackgroundTransparency = 1, Size = UDim2.fromOffset(0, 0)})
			
			task.wait(0.02)
		end
		
		task.wait(0.5)
		particleContainer:Destroy()
	end)
	
	local oldPage = pageList[currentIndex]
	local newPage = pageList[targetIndex]
	local goingRight = targetIndex > currentIndex
	local incomingX = goingRight and -1 or 1
	local outgoingX = goingRight and  1 or -1

	newPage.Visible = true
	newPage.Position = UDim2.new(incomingX,0,0,0)

	local info = TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tIn  = tween(newPage, info, {Position = UDim2.new(0,0,0,0)})
	local tOut = tween(oldPage, info, {Position = UDim2.new(outgoingX,0,0,0)})
	tIn.Completed:Wait()

	oldPage.Visible = false
	oldPage.Position = UDim2.new(0,0,0,0)
	currentIndex = targetIndex
	setTabVisual(currentIndex)
end

-- Hook tabs
tabItems.MouseButton1Click:Connect(function() slideTo(1) end)
tabAmmo.MouseButton1Click:Connect(function()  slideTo(2) end)
tabMisc.MouseButton1Click:Connect(function()  slideTo(3) end)
tabShop.MouseButton1Click:Connect(function() slideTo(4) end)

-- Click bindings
tabCrates.MouseButton1Click:Connect(function() slideTo(5) end)
tabTrash.MouseButton1Click:Connect(function()  slideTo(6) end)
tabMods.MouseButton1Click:Connect(function()   slideTo(7) end)

----------------------------------------------------------------------
-- Dragging (drag the title bar; clicking tabs won't drag)
----------------------------------------------------------------------
do
	local drag = {dragging = false, dragStart = nil, startPos = nil, dragInput = nil}
	local function pointIn(obj, p)
		local pos, size = obj.AbsolutePosition, obj.AbsoluteSize
		return p.X >= pos.X and p.X <= pos.X + size.X and p.Y >= pos.Y and p.Y <= pos.Y + size.Y
	end

titleBar.InputBegan:Connect(function(input)
	if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then
		return
	end
	for _, child in ipairs(tabsStrip:GetChildren()) do
		if child:IsA("GuiButton") and pointIn(child, input.Position) then
			return
		end
	end
	drag.dragging = true
	drag.dragStart = input.Position
	drag.startPos = win.Position
	input.Changed:Connect(function()
		if input.UserInputState == Enum.UserInputState.End then drag.dragging = false end
	end)
end)

titleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		drag.dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if input == drag.dragInput and drag.dragging then
		local delta = input.Position - drag.dragStart
		win.Position = UDim2.new(drag.startPos.X.Scale, drag.startPos.X.Offset + delta.X, drag.startPos.Y.Scale, drag.startPos.Y.Offset + delta.Y)
	end
end)
end

----------------------------------------------------------------------
-- Left Control: modern zoom-fade toggle (minimize/restore)
----------------------------------------------------------------------
local anim = {
	scale = Instance.new("UIScale"),
	fader = Instance.new("Frame"),
	homePos = win.Position,
	isOpen = false,
	animLock = false,
	windowReady = false
}
anim.scale.Scale = 1
anim.scale.Parent = win
anim.fader.BackgroundColor3 = Color3.fromRGB(18, 6, 28)
anim.fader.BackgroundTransparency = 1
anim.fader.BorderSizePixel = 0
anim.fader.Size = UDim2.fromScale(1,1)
anim.fader.ZIndex = 999
anim.fader.Parent = win
corner(anim.fader, 14)

function openWindow()
	if anim.animLock or anim.isOpen or not anim.windowReady then return end
	anim.animLock = true
	win.Visible = true
	anim.scale.Scale = 0.96
	anim.fader.BackgroundTransparency = 0
	win.Position = anim.homePos + UDim2.fromOffset(0, 8)

	-- Spawn sparkles during open
	task.spawn(function()
		for i = 1, 25 do
			local sparkle = Instance.new("Frame")
			sparkle.AnchorPoint = Vector2.new(0.5, 0.5)
			sparkle.Position = UDim2.fromScale(0.5, 0.5)
			sparkle.Size = UDim2.fromOffset(4, 4)
			sparkle.BackgroundColor3 = i % 2 == 0 and CYAN or MAGENTA
			sparkle.BackgroundTransparency = 0.3
			sparkle.BorderSizePixel = 0
			sparkle.ZIndex = 1000
			sparkle.Parent = win
			corner(sparkle, 4)
			
			local angle = math.rad(i * (360/25))
			local distance = math.random(100, 250)
			local endX = 0.5 + math.cos(angle) * (distance / win.AbsoluteSize.X)
			local endY = 0.5 + math.sin(angle) * (distance / win.AbsoluteSize.Y)
			
			local t1 = tween(sparkle, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
				{Position = UDim2.fromScale(endX, endY), BackgroundTransparency = 1, Size = UDim2.fromOffset(0, 0)})
			t1.Completed:Connect(function() sparkle:Destroy() end)
			
			task.wait(0.02)
		end
	end)

	tween(anim.fader, TweenInfo.new(0.28, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	tween(win,   TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = anim.homePos})
	local up = tween(anim.scale, TweenInfo.new(0.16, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {Scale = 1.03})
	up.Completed:Wait()
	tween(anim.scale, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Scale = 1})

	anim.isOpen, anim.animLock = true, false
end

function closeWindow()
	if anim.animLock or not anim.isOpen or not anim.windowReady then return end
	anim.animLock = true
	
	-- Spawn stars that implode to center
	task.spawn(function()
		for i = 1, 20 do
			local star = Instance.new("Frame")
			star.AnchorPoint = Vector2.new(0.5, 0.5)
			local angle = math.rad(i * (360/20))
			local startDist = 200
			local startX = 0.5 + math.cos(angle) * (startDist / win.AbsoluteSize.X)
			local startY = 0.5 + math.sin(angle) * (startDist / win.AbsoluteSize.Y)
			star.Position = UDim2.fromScale(startX, startY)
			star.Size = UDim2.fromOffset(6, 6)
			star.BackgroundColor3 = i % 2 == 0 and MAGENTA or CYAN
			star.BackgroundTransparency = 0.2
			star.BorderSizePixel = 0
			star.ZIndex = 1000
			star.Parent = win
			corner(star, 6)
			
			local glow = Instance.new("Frame")
			glow.AnchorPoint = Vector2.new(0.5, 0.5)
			glow.Position = UDim2.fromScale(0.5, 0.5)
			glow.Size = UDim2.fromOffset(12, 12)
			glow.BackgroundColor3 = star.BackgroundColor3
			glow.BackgroundTransparency = 0.75
			glow.BorderSizePixel = 0
			glow.Parent = star
			corner(glow, 12)
			
			local t1 = tween(star, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), 
				{Position = UDim2.fromScale(0.5, 0.5), BackgroundTransparency = 1, Size = UDim2.fromOffset(0, 0)})
			t1.Completed:Connect(function() star:Destroy() end)
			
			task.wait(0.015)
		end
	end)
	
	tween(anim.fader, TweenInfo.new(0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 0})
	tween(win,   TweenInfo.new(0.24, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = anim.homePos + UDim2.fromOffset(0, 8)})
	local down = tween(anim.scale, TweenInfo.new(0.24, Enum.EasingStyle.Quint, Enum.EasingDirection.In), {Scale = 0.94})
	down.Completed:Wait()
	win.Visible = false
	anim.isOpen, anim.animLock = false, false
end

function toggleWindow()
	if not anim.windowReady then return end
	if anim.isOpen then closeWindow() else openWindow() end
end

-- Replace the old LeftControl handler with this N-key handler.
-- This respects your zoom-fade open/close via toggleWindow() and
-- ignores key presses while typing in a TextBox (e.g., search bar).

UIS.InputBegan:Connect(function(input, processed)
	if processed then return end
	-- Don't toggle while typing inside a TextBox
	if UIS:GetFocusedTextBox() then return end

	if input.UserInputType == Enum.UserInputType.Keyboard
		and input.KeyCode == Enum.KeyCode.N then
		toggleWindow() -- uses your existing open/close animation
	end
end)

----------------------------------------------------------------------
-- Full-screen cinematic intro (covers CoreGui). Includes one-time SFX.
----------------------------------------------------------------------
function safeSetCoreAll(enabled)
	for i = 1, 40 do
		local ok1 = pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, enabled) end)
		local ok2 = pcall(function() StarterGui:SetCore("TopbarEnabled", enabled) end)
		if ok1 and ok2 then return end
		task.wait(0.1)
	end
end

local IntroAnimation = {}
do
	function IntroAnimation.createOverlay(parent)
		local overlay = Instance.new("Frame")
		overlay.Name = "CinematicOverlay"
		overlay.BackgroundColor3 = BG
		overlay.Size = UDim2.fromScale(1, 1)
		overlay.ZIndex = 100
		overlay.ClipsDescendants = true
		overlay.Parent = parent
		return overlay
	end

	function IntroAnimation.createVignette(parent)
		local vignette = Instance.new("Frame")
		vignette.BackgroundTransparency = 1
		vignette.Size = UDim2.fromScale(1, 1)
		vignette.ZIndex = 102
		vignette.Parent = parent
		local vigGrad = Instance.new("UIGradient")
		vigGrad.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(30, 12, 45)),
			ColorSequenceKeypoint.new(0.60, Color3.fromRGB(30, 12, 45)),
			ColorSequenceKeypoint.new(1.00, Color3.fromRGB(15, 5, 25))
		}
		vigGrad.Rotation = 90
		vigGrad.Parent = vignette
	end

	function IntroAnimation.createParallaxStars(parent)
		local starRoot = Instance.new("Frame")
		starRoot.BackgroundTransparency = 1
		starRoot.Size = UDim2.fromScale(1,1)
		starRoot.ZIndex = 103
		starRoot.Parent = parent

		local layers = {
			{count = 120, speed = 10,  size = Vector2.new(2,2), alpha = 0.45},
			{count = 70,  speed = 25,  size = Vector2.new(3,3), alpha = 0.55},
			{count = 28,  speed = 55,  size = Vector2.new(4,4), alpha = 0.70},
		}
		local movers = {}
		local function makeStar(p, sz, a)
			local s = Instance.new("Frame")
			s.BackgroundColor3 = WHITE
			s.BackgroundTransparency = 1 - a
			s.Size = UDim2.fromOffset(sz.X, sz.Y)
			s.Position = UDim2.fromScale(math.random(), math.random())
			s.ZIndex = 103
			s.Parent = p
			local glow = Instance.new("Frame")
			glow.AnchorPoint = Vector2.new(0.5, 0.5)
			glow.Position = UDim2.fromScale(0.5, 0.5)
			glow.Size = UDim2.fromOffset(sz.X*3, sz.Y*3)
			glow.BackgroundColor3 = MAGENTA:Lerp(CYAN, math.random())
			glow.BackgroundTransparency = 0.82
			glow.Parent = s
			corner(glow, math.max(sz.X, sz.Y))
			corner(s, math.max(2, math.max(sz.X, sz.Y)))
			return s
		end
		for _, l in ipairs(layers) do
			for i=1, l.count do
				local s = makeStar(starRoot, l.size, l.alpha)
				table.insert(movers, {s = s, speed = l.speed})
			end
		end
		return RunService.RenderStepped:Connect(function(dt)
			for _, m in ipairs(movers) do
				local p = m.s.Position
				local x = p.X.Scale + (m.speed * dt)/100
				local y = p.Y.Scale + (m.speed * dt)/300
				if x > 1.1 then x = -0.1 end
				if y > 1.1 then y = -0.1 end
				m.s.Position = UDim2.fromScale(x, y)
			end
		end)
	end

	function IntroAnimation.createShootingStreaks(parent)
		local streakRoot = Instance.new("Frame")
		streakRoot.BackgroundTransparency = 1
		streakRoot.Size = UDim2.fromScale(1,1)
		streakRoot.ZIndex = 104
		streakRoot.Parent = parent
		task.spawn(function()
			while streakRoot.Parent do
				local st = Instance.new("Frame")
				st.BackgroundColor3 = CYAN:Lerp(MAGENTA, math.random())
				st.BackgroundTransparency = 0.15
				st.Size = UDim2.fromOffset(math.random(120, 220), 2)
				st.AnchorPoint = Vector2.new(0.5, 0.5)
				local y = math.random()
				st.Position = UDim2.fromScale(-0.1, y)
				st.Rotation = -10 + math.random(-6, 6)
				st.Parent = streakRoot
				local g = Instance.new("UIGradient")
				g.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, WHITE), ColorSequenceKeypoint.new(0.3, WHITE), ColorSequenceKeypoint.new(1, WHITE)}
				g.Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(0.85, 0.3), NumberSequenceKeypoint.new(1, 1)}
				g.Parent = st
				tween(st, TweenInfo.new(0.9, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.fromScale(1.2, y)}).Completed:Wait()
				st:Destroy()
				task.wait(math.random(12, 22)/100)
			end
		end)
	end
end

function playStunningIntro()
	local introGui = Instance.new("ScreenGui")
	introGui.Name = "PT_Intro"
	introGui.IgnoreGuiInset = true
	introGui.ResetOnSpawn = false
	introGui.DisplayOrder = 1_000_000
	introGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	introGui.Parent = playerGui

	safeSetCoreAll(false)

	local sfx = Instance.new("Sound")
	sfx.SoundId = "rbxassetid://7112183471"
	sfx.Volume = 0.7
	sfx.RollOffMode = Enum.RollOffMode.Linear
	sfx.Parent = SoundService
	sfx:Play()
	sfx.Ended:Connect(function() sfx:Destroy() end)

	local overlay = IntroAnimation.createOverlay(introGui)
	IntroAnimation.createVignette(overlay)
	local starConn = IntroAnimation.createParallaxStars(overlay)
	IntroAnimation.createShootingStreaks(overlay)

	local splash = Instance.new("ImageLabel")
	splash.Name = "SplashImage"
	splash.BackgroundTransparency = 1
	splash.AnchorPoint = Vector2.new(0.5, 0.5)
	splash.Position = UDim2.fromScale(0.5, 0.5)
	splash.Size = UDim2.fromOffset(220, 140)
	splash.Image = "rbxassetid://127277196439432"
	splash.ScaleType = Enum.ScaleType.Fit
	splash.ZIndex = 110
	splash.Parent = overlay
	corner(splash, 16)

	local EXPAND_TIME, SHRINK_TIME, FADE_TIME = 3.5, 2.0, 1.0
	tween(splash, TweenInfo.new(EXPAND_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromScale(1,1)}).Completed:Wait()
	tween(splash, TweenInfo.new(SHRINK_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(280,175)}).Completed:Wait()
	tween(splash, TweenInfo.new(FADE_TIME), {ImageTransparency = 1}).Completed:Wait()

	if starConn then starConn:Disconnect() end
	introGui:Destroy()
	safeSetCoreAll(true)

	disableBackpackPermanently()

	win.Visible = true
	anim.homePos = win.Position
	anim.isOpen = true
	anim.windowReady = true
end

-- Run the intro (sound plays once here)
playStunningIntro()
