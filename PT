-- PT Hack :3 â€” Full build: cinematic full-screen intro + refined main GUI
-- Persist across death + one-time intro SFX (rbxassetid://7112183471)

local Players      = game:GetService("Players")
local UIS          = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService   = game:GetService("RunService")
local StarterGui   = game:GetService("StarterGui")
local SoundService = game:GetService("SoundService")

-- Kick if not in the correct place (122675988530857)
-- Put this near the top of the LocalScript, before any other logic runs.

do
	local REQUIRED_PLACE_ID = 122675988530857
	-- Remove the IsStudio() check if you also want this to trigger while testing in Studio.
	if not RunService:IsStudio() and game.PlaceId ~= REQUIRED_PLACE_ID then
		local lp = Players.LocalPlayer
		task.defer(function()
			pcall(function()
				lp:Kick("Wrong game buddy :3")
			end)
		end)
		-- Prevent the rest of the script from continuing
		while true do task.wait(1e6) end
	end
end

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Permanently disable the Roblox inventory (Backpack)
local function disableBackpackPermanently()
	-- Try until Core is ready
	for i = 1, 50 do
		local ok = pcall(function()
			game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		end)
		if ok then break end
		task.wait(0.1)
	end
	-- Reassert on respawn just in case
	game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
		pcall(function()
			game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		end)
	end)
end

-- Call once at startup
disableBackpackPermanently()

-- One-time notification to the local player at script start.
-- Tries Roblox CoreGui notification first; if SetCore isn't ready,
-- shows a custom bottom-right toast instead.

local function sendIntroNotification()
	-- Try Roblox notification
	for i = 1, 30 do
		local ok = pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title    = "PT Hack :3",
				Text     = "Script made by: ilovegay1113",
				Duration = 6,
				-- Icon = "rbxassetid://<optionalIconId>"
			})
		end)
		if ok then return end
		task.wait(0.1)
	end

	-- Fallback: bottom-right toast (always local-only)
	local playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

	local toastGui = Instance.new("ScreenGui")
	toastGui.Name = "PT_Toast"
	toastGui.IgnoreGuiInset = true
	toastGui.ResetOnSpawn = false
	toastGui.DisplayOrder = 999999
	toastGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	toastGui.Parent = playerGui

	local toast = Instance.new("Frame")
	toast.AnchorPoint = Vector2.new(1,1)
	toast.Position = UDim2.new(1, 340, 1, -12) -- start offscreen right
	toast.Size = UDim2.new(0, 320, 0, 56)
	toast.BackgroundColor3 = Color3.fromRGB(43, 18, 56)
	toast.BackgroundTransparency = 0.08
	toast.BorderSizePixel = 0
	toast.Parent = toastGui

	local c = Instance.new("UICorner", toast) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", toast) s.Color = Color3.fromRGB(170, 82, 205) s.Transparency = 0.25 s.Thickness = 1

	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Text = "Script made by: ilovegay1113"
	label.Font = Enum.Font.Gotham
	label.TextSize = 14
	label.TextColor3 = Color3.new(1,1,1)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.TextWrapped = true
	label.Size = UDim2.new(1, -20, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.Parent = toast

	-- Slide-in
	game:GetService("TweenService")
		:Create(toast, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(1, -12, 1, -12)})
		:Play()

	-- Auto-hide after 6s
	task.delay(6, function()
		local t = game:GetService("TweenService")
			:Create(toast, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				Position = UDim2.new(1, 340, 1, -12),
				BackgroundTransparency = 1
			})
		t:Play()
		t.Completed:Once(function() toastGui:Destroy() end)
	end)
end

-- Call this once at startup (before your intro starts)
sendIntroNotification()

-- Singleton guard: ensure UI is created only once per join/session
if player:GetAttribute("PT_UI_INITIALIZED") then
	-- UI was already built (and persists across death); nothing else to do.
	return
end
player:SetAttribute("PT_UI_INITIALIZED", true)

-- Theme
local BG        = Color3.fromRGB(43, 18, 56)    -- deep purple
local ACCENT    = Color3.fromRGB(66, 47, 88)    -- darker bar
local TAB       = Color3.fromRGB(145, 59, 167)  -- tab idle
local TAB_SEL   = Color3.fromRGB(170, 82, 205)  -- tab active
local CYAN      = Color3.fromRGB(90, 220, 255)  -- neon accent
local MAGENTA   = Color3.fromRGB(255, 105, 230) -- neon accent
local WHITE     = Color3.new(1,1,1)

-- Layout constants
local PAD, TITLE_H, TABS_H, GAP, TAB_W, TAB_GAP = 14, 48, 36, 10, 132, 12

-- Utilities
local function corner(parent, r)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, r or 12)
	c.Parent = parent
	return c
end

local function stroke(parent, color, thickness, transparency)
	local s = Instance.new("UIStroke")
	s.Color = color
	s.Thickness = thickness or 1.25
	s.Transparency = transparency or 0.35
	s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	s.Parent = parent
	return s
end

local function tween(obj, info, props)
	local t = TweenService:Create(obj, info, props)
	t:Play()
	return t
end

----------------------------------------------------------------------
-- ScreenGui for the main app (persists across respawn)
----------------------------------------------------------------------
local gui = Instance.new("ScreenGui")
gui.Name = "PT Hack :3"
gui.ResetOnSpawn = false       -- IMPORTANT: keep GUI through death/respawn
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
pcall(function()
	gui.ClipToDeviceSafeArea = true
	gui.ScreenInsets = Enum.ScreenInsets.CoreUISafeInsets
end)
gui.Parent = playerGui

----------------------------------------------------------------------
-- Window shell (centered, aligned)
----------------------------------------------------------------------
local win = Instance.new("Frame")
win.Name = "MainFrame"
win.AnchorPoint = Vector2.new(0.5, 0.5)
win.Position = UDim2.new(0.5, 0, 0.5, 0)
win.Size = UDim2.new(0, 560, 0, 360)
win.BackgroundColor3 = BG
win.BorderSizePixel = 0
win.Visible = false -- revealed after intro
win.Parent = gui
corner(win, 14)
stroke(win, Color3.fromRGB(200,120,255), 1.2, 0.5)

-- Inner container for consistent spacing
local container = Instance.new("Frame")
container.BackgroundTransparency = 1
container.Size = UDim2.new(1, -PAD*2, 1, -PAD*2)
container.Position = UDim2.new(0, PAD, 0, PAD)
container.Parent = win

----------------------------------------------------------------------
-- Title bar (draggable)
----------------------------------------------------------------------
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.BackgroundColor3 = ACCENT
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 48)
titleBar.Active = true
titleBar.Parent = container
corner(titleBar, 10)
stroke(titleBar, Color3.fromRGB(255,160,255), 1, 0.6)

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = "PT Hack :3"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = WHITE
title.TextXAlignment = Enum.TextXAlignment.Left
title.Size = UDim2.new(1, -PAD*2, 1, 0)
title.Position = UDim2.new(0, PAD, 0, 0)
title.Parent = titleBar

----------------------------------------------------------------------
-- Tabs row with horizontal scrolling (replaces your tabsStrip Frame block)
----------------------------------------------------------------------
local tabsStrip = Instance.new("ScrollingFrame")
tabsStrip.Name = "TabsStrip"
tabsStrip.Parent = container
tabsStrip.BackgroundTransparency = 1
tabsStrip.Size = UDim2.new(1, 0, 0, TABS_H)
tabsStrip.Position = UDim2.new(0, 0, 0, TITLE_H + GAP)
tabsStrip.BorderSizePixel = 0
tabsStrip.ScrollingDirection = Enum.ScrollingDirection.X
tabsStrip.AutomaticCanvasSize = Enum.AutomaticSize.X
tabsStrip.ScrollBarThickness = 6
tabsStrip.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- theme
tabsStrip.CanvasSize = UDim2.new(0, 0, 0, 0)

local tabsPad = Instance.new("UIPadding", tabsStrip)
tabsPad.PaddingLeft = UDim.new(0, 8)
tabsPad.PaddingRight = UDim.new(0, 8)

-- After you create tabsStrip (ScrollingFrame) and tabsPad:
local SCROLLBAR_GAP = 8  -- how far below the tabs the bar sits

-- Make the strip a bit taller to reserve space for the bar
tabsStrip.Size = UDim2.new(1, 0, 0, TABS_H + SCROLLBAR_GAP)

-- Add bottom padding so content doesn't touch the bar
tabsPad.PaddingBottom = UDim.new(0, SCROLLBAR_GAP)

-- Optional: a tiny top pad to center visually
tabsPad.PaddingTop = UDim.new(0, 2)

local tabsLayout = Instance.new("UIListLayout", tabsStrip)
tabsLayout.FillDirection = Enum.FillDirection.Horizontal
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left -- left, because we can scroll
tabsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
tabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
tabsLayout.Padding = UDim.new(0, TAB_GAP)

local function makeTab(label, order)
	local b = Instance.new("TextButton")
	b.Name = label
	b.LayoutOrder = order
	b.Text = label
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = WHITE
	b.AutoButtonColor = false
	b.BackgroundColor3 = TAB
	b.BorderSizePixel = 0
	b.Size = UDim2.new(0, TAB_W, 0, 32)
	b.Parent = tabsStrip
	corner(b, 8)
	stroke(b, TAB_SEL, 1, 0.75)

	-- Per-tab underline indicator
	local underline = Instance.new("Frame")
	underline.Name = "Underline"
	underline.AnchorPoint = Vector2.new(0.5, 1)
	underline.Position = UDim2.new(0.5, 0, 1, 3)
	underline.Size = UDim2.new(0, 0, 0, 3)
	underline.BackgroundColor3 = WHITE
	underline.BorderSizePixel = 0
	underline.Parent = b
	local ug = Instance.new("UIGradient")
	ug.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, MAGENTA),
		ColorSequenceKeypoint.new(1, CYAN)
	}
	ug.Parent = underline
	corner(underline, 3)

	b.MouseEnter:Connect(function()
		tween(b, TweenInfo.new(0.15), {BackgroundColor3 = TAB_SEL})
	end)
	b.MouseLeave:Connect(function() end)

	return b
end

local tabItems = makeTab("Items", 1)
local tabAmmo  = makeTab("Ammo",  2)
local tabMisc  = makeTab("Misc",  3)
local tabShop  = makeTab("Shop",  4)

-- Tabs (add two more)
local tabCrates = makeTab("Crates", 5)
local tabTrash  = makeTab("Trash",  6)

local tabList  = {tabItems, tabAmmo, tabMisc, tabShop, tabCrates, tabTrash}

----------------------------------------------------------------------
-- Content area fills remaining space
----------------------------------------------------------------------
local contentTop = TITLE_H + GAP + TABS_H + GAP
local pages = Instance.new("Frame")
pages.Name = "Pages"
pages.BackgroundColor3 = Color3.fromRGB(30, 12, 40)
pages.BackgroundTransparency = 0.05
pages.Position = UDim2.new(0, 0, 0, contentTop)
pages.Size = UDim2.new(1, 0, 1, -contentTop)
pages.ClipsDescendants = true
pages.Parent = container
corner(pages, 10)
stroke(pages, Color3.fromRGB(210,120,255), 1, 0.6)

local pagesGrad = Instance.new("UIGradient")
pagesGrad.Rotation = 45
pagesGrad.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0.00, Color3.fromRGB(55,26,75)),
	ColorSequenceKeypoint.new(0.60, Color3.fromRGB(43,18,56)),
	ColorSequenceKeypoint.new(1.00, Color3.fromRGB(35,14,47)),
}
pagesGrad.Parent = pages

-- Empty pages for tabs
local function makePage(name)
	local f = Instance.new("Frame")
	f.Name = name
	f.BackgroundTransparency = 1
	f.BorderSizePixel = 0
	f.Size = UDim2.new(1, 0, 1, 0)
	f.Visible = false
	f.Parent = pages
	return f
end
local pageItems = makePage("ItemsPage")
-- [Items UI] put right after: local pageItems = makePage("ItemsPage")

-- Top search bar
local itemsSearch = Instance.new("TextBox")
itemsSearch.Name = "ItemsSearch"
itemsSearch.Parent = pageItems
itemsSearch.ClearTextOnFocus = false
itemsSearch.PlaceholderText = "Search items..."
itemsSearch.Text = ""
itemsSearch.Font = Enum.Font.Gotham
itemsSearch.TextSize = 14
itemsSearch.TextColor3 = Color3.new(1,1,1)
itemsSearch.PlaceholderColor3 = Color3.fromRGB(200, 190, 220)
itemsSearch.BackgroundColor3 = Color3.fromRGB(66, 47, 88) -- ACCENT tone
itemsSearch.BorderSizePixel = 0
itemsSearch.Size = UDim2.new(1, -16, 0, 32)
itemsSearch.Position = UDim2.new(0, 8, 0, 8)
local itemsSearchCorner = Instance.new("UICorner", itemsSearch) itemsSearchCorner.CornerRadius = UDim.new(0, 8)

-- Scroll list (right-side vertical scrollbar)
local itemsList = Instance.new("ScrollingFrame")
itemsList.Name = "ItemsList"
itemsList.Parent = pageItems
itemsList.BackgroundTransparency = 1
itemsList.BorderSizePixel = 0
itemsList.ScrollBarThickness = 8
itemsList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- TAB_SEL tone
itemsList.ScrollingDirection = Enum.ScrollingDirection.Y
itemsList.AutomaticCanvasSize = Enum.AutomaticSize.Y
itemsList.Size = UDim2.new(1, -16, 1, -56) -- below search (32) + margins
itemsList.Position = UDim2.new(0, 8, 0, 48)

local pad = Instance.new("UIPadding", itemsList)
pad.PaddingTop = UDim.new(0, 8)
pad.PaddingLeft = UDim.new(0, 8)
pad.PaddingRight = UDim.new(0, 8)
pad.PaddingBottom = UDim.new(0, 8)

local itemsLayout = Instance.new("UIListLayout", itemsList)
itemsLayout.SortOrder = Enum.SortOrder.Name -- alphabetical by name by default
itemsLayout.Padding = UDim.new(0, 6)

-- Button factory (visuals match your theme)
local function makeItemButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) -- TAB
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local stroke = Instance.new("UIStroke", b)
	stroke.Color = Color3.fromRGB(170, 82, 205) -- TAB_SEL
	stroke.Thickness = 1
	stroke.Transparency = 0.6
	-- Hover glow
	b.MouseEnter:Connect(function()
		b.BackgroundColor3 = Color3.fromRGB(170, 82, 205)
		stroke.Transparency = 0.4
	end)
	b.MouseLeave:Connect(function()
		b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
		stroke.Transparency = 0.6
	end)
	return b
end
-- [Items logic] live scan of Models, search, and teleport

-- Root getter (resolves path each time in case the hierarchy reloads)
local function getLootRoot()
	local env = workspace:FindFirstChild("Environment")
	if not env then return nil end
	local wms = env:FindFirstChild("WorldModelSpawns")
	if not wms then return nil end
	local loot = wms:FindFirstChild("LootSpawnPoints")
	return loot
end

-- Storage
local modelButton = {}   -- [Model] = TextButton
local nameChanged = {}   -- [Model] = RBXScriptConnection
local observingRoot -- current root folder we watch
local rootConnections = {} -- to disconnect when root changes

-- Teleport helper
local function teleportToModel(m)
	if not m or not m:IsA("Model") then return end
	local char = player.Character or player.CharacterAdded:Wait()
	if not char then return end
	-- Prefer Pivot; fall back to PrimaryPart or part in model
	local pivotCFrame
	local ok, cf = pcall(function() return m:GetPivot() end)
	if ok then
		pivotCFrame = cf
	elseif m.PrimaryPart then
		pivotCFrame = m.PrimaryPart.CFrame
	else
		local part = m:FindFirstChildWhichIsA("BasePart", true)
		if part then pivotCFrame = part.CFrame end
	end
	if not pivotCFrame then return end

	local offset = CFrame.new(0, 4, 0) -- small lift above pivot
	-- Use Character:PivotTo for a clean teleport
	char:PivotTo(pivotCFrame * offset)
end

-- Create/remove buttons
local function addModel(m)
	if modelButton[m] then return end
	local b = makeItemButton(m.Name)
	b.Parent = itemsList
	modelButton[m] = b

	-- Click to TP
	b.MouseButton1Click:Connect(function()
		teleportToModel(m)
	end)

	-- Keep name in sync
	nameChanged[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
		b.Name = m.Name
		b.Text = m.Name
	end)
end

local function removeModel(m)
	local b = modelButton[m]
	if b then b:Destroy() end
	modelButton[m] = nil
	if nameChanged[m] then nameChanged[m]:Disconnect() nameChanged[m] = nil end
end

-- Populate once (scans all descendants; only Models)
local function populateAll(root)
	for m, _ in pairs(modelButton) do removeModel(m) end
	if not root then return end
	for _, inst in ipairs(root:GetDescendants()) do
		if inst:IsA("Model") then addModel(inst) end
	end
end

-- Filter by search text (case-insensitive; hides/show buttons)
local function applySearchFilter()
	local query = string.lower(itemsSearch.Text)
	for m, b in pairs(modelButton) do
		if query == "" then
			b.Visible = true
		else
			b.Visible = string.find(string.lower(m.Name), query, 1, true) ~= nil
		end
	end
end
itemsSearch:GetPropertyChangedSignal("Text"):Connect(applySearchFilter)

-- Attach watchers to the current root so lists auto-update
local function disconnectRootWatchers()
	for _, c in ipairs(rootConnections) do
		if c then c:Disconnect() end
	end
	rootConnections = {}
	observingRoot = nil
end

local function attachRootWatchers(root)
	disconnectRootWatchers()
	if not root then return end
	observingRoot = root

	-- Build initial list
	populateAll(root)
	applySearchFilter()

	-- Watch for new/removed models under the root
	table.insert(rootConnections, root.DescendantAdded:Connect(function(inst)
		if inst:IsA("Model") then
			addModel(inst)
			applySearchFilter()
		end
	end))
	table.insert(rootConnections, root.DescendantRemoving:Connect(function(inst)
		if inst:IsA("Model") then
			removeModel(inst)
		end
	end))

	-- If the root itself moves or gets replaced, weâ€™ll retry binding
	table.insert(rootConnections, root.AncestryChanged:Connect(function(_, parent)
		if not parent then
			-- lost root
			task.defer(function()
				disconnectRootWatchers()
			end)
		end
	end))
end

-- Poll the path periodically and re-bind if the root changes (covers reloads)
task.spawn(function()
	local last
	while pageItems.Parent do
		local root = getLootRoot()
		if root ~= last then
			attachRootWatchers(root)
			last = root
		end
		task.wait(1.0) -- light polling; keeps tabs updated with spawners that re-create the tree
	end
end)
local pageAmmo  = makePage("AmmoPage")

-- [Ammo UI] put right after: local pageAmmo = makePage("AmmoPage")

local ammoList = Instance.new("ScrollingFrame")
ammoList.Name = "AmmoList"
ammoList.Parent = pageAmmo
ammoList.BackgroundTransparency = 1
ammoList.BorderSizePixel = 0
ammoList.AutomaticCanvasSize = Enum.AutomaticSize.Y
ammoList.ScrollingDirection = Enum.ScrollingDirection.Y
ammoList.ScrollBarThickness = 8
ammoList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205) -- theme
ammoList.Size = UDim2.new(1, -16, 1, -16)
ammoList.Position = UDim2.new(0, 8, 0, 8)

local ammoPad = Instance.new("UIPadding", ammoList)
ammoPad.PaddingTop = UDim.new(0, 8)
ammoPad.PaddingLeft = UDim.new(0, 8)
ammoPad.PaddingRight = UDim.new(0, 8)
ammoPad.PaddingBottom = UDim.new(0, 8)

local ammoLayout = Instance.new("UIListLayout", ammoList)
ammoLayout.SortOrder = Enum.SortOrder.Name -- alphabetical by button name
ammoLayout.Padding = UDim.new(0, 6)

local function makeAmmoButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) -- tab color
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	-- style
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- [Ammo logic] MeshPart scan + live updates + teleport on click

-- Resolve the ammo root each time (handles reloads)
local function getAmmoRoot()
	local env = workspace:FindFirstChild("Environment")
	if not env then return nil end
	local inter = env:FindFirstChild("Interactable")
	if not inter then return nil end
	local ammo = inter:FindFirstChild("Ammo")
	return ammo
end

-- Teleport helper for MeshPart
local function teleportToPart(part: MeshPart)
	if not part or not part:IsA("BasePart") then return end
	local char = player.Character or player.CharacterAdded:Wait()
	if not char then return end
	-- Stand slightly above the part
	char:PivotTo(part.CFrame * CFrame.new(0, 4, 0))
end

-- Storage and cleanup (typed)
local meshButton: { [Instance]: TextButton } = {}
local nameConn:   { [Instance]: RBXScriptConnection } = {}
local rootConns:  { RBXScriptConnection } = {}
local observedRoot: Instance? = nil

local function addMesh(part: MeshPart)
	if meshButton[part] then return end
	local b = makeAmmoButton(part.Name)
	b.Parent = ammoList
	meshButton[part] = b

	-- Click to TP
	b.MouseButton1Click:Connect(function()
		teleportToPart(part)
	end)

	-- Keep label synced with part.Name
	nameConn[part] = part:GetPropertyChangedSignal("Name"):Connect(function()
		b.Name = part.Name
		b.Text = part.Name
	end)
end

local function removeMesh(part: MeshPart)
	local b = meshButton[part]
	if b then b:Destroy() end
	meshButton[part] = nil
	if nameConn[part] then nameConn[part]:Disconnect() nameConn[part] = nil end
end

local function clearAll()
	for inst,_ in pairs(meshButton) do removeMesh(inst) end
end

-- Initial/refresh population
local function populateAll(root: Instance?)
	clearAll()
	if not root then return end
	for _, inst in ipairs(root:GetDescendants()) do
		if inst:IsA("MeshPart") then
			addMesh(inst)
		end
	end
end

-- Manage watchers on the ammo root so list auto-updates
local function disconnectRootWatchers()
	for _, c in ipairs(rootConns) do
		if c then c:Disconnect() end
	end
	rootConns = {}
	observedRoot = nil
end

local function attachRootWatchers(root: Instance?)
	disconnectRootWatchers()
	if not root then return end
	observedRoot = root

	populateAll(root)

	table.insert(rootConns, root.DescendantAdded:Connect(function(inst)
		if inst:IsA("MeshPart") then addMesh(inst) end
	end))
	table.insert(rootConns, root.DescendantRemoving:Connect(function(inst)
		if inst:IsA("MeshPart") then removeMesh(inst) end
	end))
	table.insert(rootConns, root.AncestryChanged:Connect(function(_, parent)
		if not parent then disconnectRootWatchers() end
	end))
end

-- Rebind to the path if it gets recreated (keeps the tab always updating)
task.spawn(function()
	local last
	while pageAmmo.Parent do
		local root = getAmmoRoot()
		if root ~= last then
			attachRootWatchers(root)
			last = root
		end
		task.wait(1.0)
	end
end)

local pageMisc  = makePage("MiscPage")

-- [Misc UI] Toggle row
local miscContainer = Instance.new("Frame")
miscContainer.BackgroundTransparency = 1
miscContainer.Size = UDim2.new(1, -16, 1, -16)
miscContainer.Position = UDim2.new(0, 8, 0, 8)
miscContainer.Parent = pageMisc

local miscLayout = Instance.new("UIListLayout")
miscLayout.Padding = UDim.new(0, 10)
miscLayout.SortOrder = Enum.SortOrder.LayoutOrder
miscLayout.Parent = miscContainer

local row = Instance.new("Frame")
row.BackgroundTransparency = 1
row.Size = UDim2.new(1, 0, 0, 36)
row.Parent = miscContainer

local label = Instance.new("TextLabel")
label.BackgroundTransparency = 1
label.Text = "Infinite Stamina"
label.Font = Enum.Font.GothamBold
label.TextSize = 16
label.TextColor3 = Color3.new(1,1,1)
label.TextXAlignment = Enum.TextXAlignment.Left
label.Size = UDim2.new(1, -120, 1, 0)
label.Parent = row

-- Pill switch (right side)
local switch = Instance.new("TextButton")
switch.Name = "InfStaminaSwitch"
switch.AutoButtonColor = false
switch.Text = ""
switch.AnchorPoint = Vector2.new(1, 0.5)
switch.Position = UDim2.new(1, 0, 0.5, 0)
switch.Size = UDim2.new(0, 64, 0, 28)
switch.BackgroundColor3 = Color3.fromRGB(66, 47, 88) -- off color
switch.BorderSizePixel = 0
switch.Parent = row
local swCorner = Instance.new("UICorner", switch) swCorner.CornerRadius = UDim.new(1, 0)
local swStroke = Instance.new("UIStroke", switch) swStroke.Color = Color3.fromRGB(170, 82, 205) swStroke.Transparency = 0.4

-- Knob
local knob = Instance.new("Frame")
knob.Name = "Knob"
knob.AnchorPoint = Vector2.new(0, 0.5)
knob.Position = UDim2.new(0, 3, 0.5, 0)
knob.Size = UDim2.new(0, 24, 0, 24)
knob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
knob.BorderSizePixel = 0
knob.Parent = switch
local kCorner = Instance.new("UICorner", knob) kCorner.CornerRadius = UDim.new(1, 0)

-- [Misc logic â€” SAFE Infinite Stamina toggle that won't break the UI]

local RunService = game:GetService("RunService")

-- UI helpers
local function setSwitchVisual(isOn: boolean)
	if isOn then
		switch.BackgroundColor3 = Color3.fromRGB(90, 220, 255) -- cyan when ON
		knob:TweenPosition(UDim2.new(1, -27, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		knob.BackgroundColor3 = Color3.fromRGB(255, 105, 230) -- magenta knob
	else
		switch.BackgroundColor3 = Color3.fromRGB(66, 47, 88) -- off
		knob:TweenPosition(UDim2.new(0, 3, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
		knob.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	end
end

-- Locate the aspect folders the movement/UI read
local function getAspectFolders()
	local char = player.Character or player.CharacterAdded:Wait()
	local config = char:FindFirstChildWhichIsA("Configuration")
	if not config then return end
	local aspects = config:FindFirstChild("ReplicatedAspects")
	if not aspects then return end
	return aspects:FindFirstChild("LocalStamina"), aspects:FindFirstChild("StaminaState")
end

-- Capture original values (so we can restore and keep the UI consistent)
local snapshot -- { lsMax, ssMax, lsThreshold, ssThreshold }
local function captureOriginalStamina()
	local ls, ss = getAspectFolders()
	if not ls and not ss then return end
	snapshot = snapshot or {}
	if ls then
		if snapshot.lsMax == nil then snapshot.lsMax = ls:GetAttribute("Max") end
		if snapshot.lsThreshold == nil then snapshot.lsThreshold = ls:GetAttribute("Threshold") end
	end
	if ss then
		if snapshot.ssMax == nil then snapshot.ssMax = ss:GetAttribute("Max") end
		if snapshot.ssThreshold == nil then snapshot.ssThreshold = ss:GetAttribute("Threshold") end
	end
end

-- Keep stamina full without changing Max or regen flags
local function pushInfiniteStamina()
	local ls, ss = getAspectFolders()
	if ls then
		local mx = ls:GetAttribute("Max") or 100
		if ls:GetAttribute("Current") ~= mx then ls:SetAttribute("Current", mx) end
		if ls:GetAttribute("AtThreshold") ~= false then ls:SetAttribute("AtThreshold", false) end
	end
	if ss then
		local mx = ss:GetAttribute("Max") or 100
		if ss:GetAttribute("Current") ~= mx then ss:SetAttribute("Current", mx) end
		if ss:GetAttribute("AtThreshold") ~= false then ss:SetAttribute("AtThreshold", false) end
	end
end

-- Restore and gently "nudge" Current so UI Change listeners re-evaluate
local function restoreOriginalStamina()
	local ls, ss = getAspectFolders()
	if snapshot then
		if ls and snapshot.lsMax then
			local cur = ls:GetAttribute("Current")
			local mx  = ls:GetAttribute("Max") or snapshot.lsMax
			-- Clamp any overshoot
			if typeof(cur) == "number" and cur > mx then ls:SetAttribute("Current", mx) end
			if snapshot.lsThreshold ~= nil then ls:SetAttribute("Threshold", snapshot.lsThreshold) end
		end
		if ss and snapshot.ssMax then
			local cur = ss:GetAttribute("Current")
			local mx  = ss:GetAttribute("Max") or snapshot.ssMax
			if typeof(cur) == "number" and cur > mx then ss:SetAttribute("Current", mx) end
			if snapshot.ssThreshold ~= nil then ss:SetAttribute("Threshold", snapshot.ssThreshold) end
		end
	end

	-- Nudge to force UI refresh even if numbers "look" the same
	task.defer(function()
		local ls2, ss2 = getAspectFolders()
		if ls2 then
			local c = ls2:GetAttribute("Current")
			if typeof(c) == "number" then
				ls2:SetAttribute("Current", math.max(0, c - 0.001))
				task.wait()
				ls2:SetAttribute("Current", c)
			end
		end
		if ss2 then
			local c = ss2:GetAttribute("Current")
			if typeof(c) == "number" then
				ss2:SetAttribute("Current", math.max(0, c - 0.001))
				task.wait()
				ss2:SetAttribute("Current", c)
			end
		end
	end)
end

-- Toggle state
local ATTR_NAME = "PT_InfiniteStamina"
local infEnabled = player:GetAttribute(ATTR_NAME) == true
local hbConn: RBXScriptConnection? = nil
local charConn: RBXScriptConnection? = nil

local function startInfLoop()
	if hbConn then hbConn:Disconnect() hbConn = nil end
	captureOriginalStamina()
	pushInfiniteStamina()
	hbConn = RunService.Heartbeat:Connect(pushInfiniteStamina)
	if charConn then charConn:Disconnect() end
	charConn = player.CharacterAdded:Connect(function()
		snapshot = nil    -- recapture per character
		task.wait(0.25)
		captureOriginalStamina()
		if infEnabled then pushInfiniteStamina() end
	end)
end

local function stopInfLoop()
	if hbConn then hbConn:Disconnect() hbConn = nil end
	if charConn then charConn:Disconnect() charConn = nil end
	restoreOriginalStamina()
end

local function setInfEnabled(on: boolean)
	infEnabled = on
	player:SetAttribute(ATTR_NAME, on)
	setSwitchVisual(on) -- uses your existing UI helper from the Misc toggle
	if on then startInfLoop() else stopInfLoop() end
end

-- Initialize from saved state and wire the toggle button "switch"
setInfEnabled(infEnabled or false)
switch.MouseButton1Click:Connect(function()
	setInfEnabled(not infEnabled)
end)

local pageShop  = makePage("ShopPage")

-- Pages (add two more)
local pageCrates = makePage("CratesPage")
local pageTrash  = makePage("TrashPage")

-- [Trash UI]
local trashList = Instance.new("ScrollingFrame")
trashList.Name = "TrashList"
trashList.Parent = pageTrash
trashList.BackgroundTransparency = 1
trashList.BorderSizePixel = 0
trashList.AutomaticCanvasSize = Enum.AutomaticSize.Y
trashList.ScrollingDirection = Enum.ScrollingDirection.Y
trashList.ScrollBarThickness = 8
trashList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
trashList.Size = UDim2.new(1, -16, 1, -16)
trashList.Position = UDim2.new(0, 8, 0, 8)

local trashPad = Instance.new("UIPadding", trashList)
trashPad.PaddingTop = UDim.new(0, 8)
trashPad.PaddingLeft = UDim.new(0, 8)
trashPad.PaddingRight = UDim.new(0, 8)
trashPad.PaddingBottom = UDim.new(0, 8)

local trashLayout = Instance.new("UIListLayout", trashList)
trashLayout.SortOrder = Enum.SortOrder.Name
trashLayout.Padding = UDim.new(0, 6)

local function makeTrashButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- [Crates UI]
local cratesList = Instance.new("ScrollingFrame")
cratesList.Name = "CratesList"
cratesList.Parent = pageCrates
cratesList.BackgroundTransparency = 1
cratesList.BorderSizePixel = 0
cratesList.AutomaticCanvasSize = Enum.AutomaticSize.Y
cratesList.ScrollingDirection = Enum.ScrollingDirection.Y
cratesList.ScrollBarThickness = 8
cratesList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
cratesList.Size = UDim2.new(1, -16, 1, -16)
cratesList.Position = UDim2.new(0, 8, 0, 8)

local cratesPad = Instance.new("UIPadding", cratesList)
cratesPad.PaddingTop = UDim.new(0, 8)
cratesPad.PaddingLeft = UDim.new(0, 8)
cratesPad.PaddingRight = UDim.new(0, 8)
cratesPad.PaddingBottom = UDim.new(0, 8)

local cratesLayout = Instance.new("UIListLayout", cratesList)
cratesLayout.SortOrder = Enum.SortOrder.Name
cratesLayout.Padding = UDim.new(0, 6)

local function makeCrateButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- [Shop UI] simple vertical list
local shopList = Instance.new("ScrollingFrame")
shopList.Name = "ShopList"
shopList.Parent = pageShop
shopList.BackgroundTransparency = 1
shopList.BorderSizePixel = 0
shopList.AutomaticCanvasSize = Enum.AutomaticSize.Y
shopList.ScrollingDirection = Enum.ScrollingDirection.Y
shopList.ScrollBarThickness = 8
shopList.ScrollBarImageColor3 = Color3.fromRGB(170, 82, 205)
shopList.Size = UDim2.new(1, -16, 1, -16)
shopList.Position = UDim2.new(0, 8, 0, 8)

local shopPad = Instance.new("UIPadding", shopList)
shopPad.PaddingTop = UDim.new(0, 8)
shopPad.PaddingLeft = UDim.new(0, 8)
shopPad.PaddingRight = UDim.new(0, 8)
shopPad.PaddingBottom = UDim.new(0, 8)

local shopLayout = Instance.new("UIListLayout", shopList)
shopLayout.SortOrder = Enum.SortOrder.Name
shopLayout.Padding = UDim.new(0, 6)

local function makeShopButton(text)
	local b = Instance.new("TextButton")
	b.Name = text
	b.Text = text
	b.AutoButtonColor = false
	b.Font = Enum.Font.GothamBold
	b.TextSize = 14
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(145, 59, 167)
	b.BorderSizePixel = 0
	b.Size = UDim2.new(1, 0, 0, 30)
	local c = Instance.new("UICorner", b) c.CornerRadius = UDim.new(0, 8)
	local s = Instance.new("UIStroke", b) s.Color = Color3.fromRGB(170, 82, 205) s.Thickness = 1 s.Transparency = 0.6
	b.MouseEnter:Connect(function() b.BackgroundColor3 = Color3.fromRGB(170, 82, 205) s.Transparency = 0.4 end)
	b.MouseLeave:Connect(function() b.BackgroundColor3 = Color3.fromRGB(145, 59, 167) s.Transparency = 0.6 end)
	return b
end

-- Replace your existing tabList/pageList with these:
local pageList  = {pageItems, pageAmmo, pageMisc, pageShop, pageCrates, pageTrash}

-- [Crates logic] Any Model named "Military Crate" in the entire workspace
local function tpToModelCrate(m: Instance)
	if not m or not m:IsA("Model") then return end
	local char = player.Character or player.CharacterAdded:Wait()
	if not char then return end
	local cf
	local ok, pivot = pcall(function() return m:GetPivot() end)
	if ok then cf = pivot
	elseif m.PrimaryPart then cf = m.PrimaryPart.CFrame
	else
		local p = m:FindFirstChildWhichIsA("BasePart", true)
		if p then cf = p.CFrame end
	end
	if not cf then return end
	char:PivotTo(cf * CFrame.new(0, 4, 0))
end

local crateButtons: { [Model]: TextButton } = {}
local crateNameConn: { [Model]: RBXScriptConnection } = {}
local crateConns: { RBXScriptConnection } = {}

local function addCrate(m: Model)
	if crateButtons[m] then return end
	if m.Name ~= "Military Crate" then return end
	local b = makeCrateButton(m.Name)
	b.Parent = cratesList
	crateButtons[m] = b
	b.MouseButton1Click:Connect(function() tpToModelCrate(m) end)
	-- If it gets renamed away, remove it
	crateNameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
		if m.Name ~= "Military Crate" then
			local btn = crateButtons[m]; if btn then btn:Destroy() end
			crateButtons[m] = nil
			if crateNameConn[m] then crateNameConn[m]:Disconnect() crateNameConn[m] = nil end
		else
			local btn = crateButtons[m]; if btn then btn.Name = m.Name; btn.Text = m.Name end
		end
	end)
end

local function removeCrate(m: Model)
	local b = crateButtons[m]
	if b then b:Destroy() end
	crateButtons[m] = nil
	if crateNameConn[m] then crateNameConn[m]:Disconnect() crateNameConn[m] = nil end
end

local function clearCrates()
	for m,_ in pairs(crateButtons) do removeCrate(m) end
end

local function populateCratesAll()
	clearCrates()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("Model") and inst.Name == "Military Crate" then
			addCrate(inst)
		end
	end
end

local function disconnectCrateWatchers()
	for _, c in ipairs(crateConns) do if c then c:Disconnect() end end
	crateConns = {}
end

local function attachCrateWatchers()
	disconnectCrateWatchers()
	populateCratesAll()

	table.insert(crateConns, workspace.DescendantAdded:Connect(function(inst)
		if inst:IsA("Model") and inst.Name == "Military Crate" then
			addCrate(inst)
		end
	end))
	table.insert(crateConns, workspace.DescendantRemoving:Connect(function(inst)
		if crateButtons[inst] then removeCrate(inst) end
	end))

	-- Light poll to catch rare renames to "Military Crate"
	task.spawn(function()
		while pageCrates.Parent do
			for _, inst in ipairs(workspace:GetDescendants()) do
				if inst:IsA("Model") and inst.Name == "Military Crate" then
					if not crateButtons[inst] then addCrate(inst) end
				end
			end
			task.wait(2.0)
		end
	end)
end

attachCrateWatchers()

-- [Trash logic â€” only direct children named "Trash Can"]
local function getHazardsRoot()
	local env = workspace:FindFirstChild("Environment")
	if not env then return nil end
	local inter = env:FindFirstChild("Interactable")
	if not inter then return nil end
	return inter:FindFirstChild("Hazards")
end

local function tpToModelTrash(m)
	if not m or not m:IsA("Model") then return end
	local char = player.Character or player.CharacterAdded:Wait()
	if not char then return end
	local cf
	local ok, pivot = pcall(function() return m:GetPivot() end)
	if ok then cf = pivot
	elseif m.PrimaryPart then cf = m.PrimaryPart.CFrame
	else
		local p = m:FindFirstChildWhichIsA("BasePart", true)
		if p then cf = p.CFrame end
	end
	if not cf then return end
	char:PivotTo(cf * CFrame.new(0, 4, 0))
end

local trashButtons   = {}  -- [Model] = TextButton
local trashNameConn  = {}  -- [Model] = RBXScriptConnection
local hazardsConns   = {}  -- { RBXScriptConnection }
local observedHazards = nil

local function removeTrashModel(m)
	local b = trashButtons[m]
	if b then b:Destroy() end
	trashButtons[m] = nil
	if trashNameConn[m] then trashNameConn[m]:Disconnect() trashNameConn[m] = nil end
end

local function addTrashModel(m)
	-- Only accept models explicitly named "Trash Can"
	if not (m and m:IsA("Model") and m.Name == "Trash Can") then return end
	if trashButtons[m] then return end

	local b = makeTrashButton(m.Name)
	b.Parent = trashList
	trashButtons[m] = b

	b.MouseButton1Click:Connect(function()
		tpToModelTrash(m)
	end)

	-- If it gets renamed away from "Trash Can", remove it from the list
	trashNameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
		if m.Name ~= "Trash Can" then
			removeTrashModel(m)
		else
			local btn = trashButtons[m]
			if btn then btn.Name = m.Name; btn.Text = m.Name end
		end
	end)
end

local function clearTrash()
	for m,_ in pairs(trashButtons) do removeTrashModel(m) end
end

-- Populate ONLY direct children that are Models named "Trash Can"
local function populateTrashDirect(root)
	clearTrash()
	if not root then return end
	for _, child in ipairs(root:GetChildren()) do
		addTrashModel(child)
	end
end

local function disconnectHazardsWatch()
	for _, c in ipairs(hazardsConns) do if c then c:Disconnect() end end
	hazardsConns = {}
	observedHazards = nil
end

local function attachHazardsWatch(root)
	disconnectHazardsWatch()
	if not root then return end
	observedHazards = root

	populateTrashDirect(root)

	-- Only watch direct children (no descendants)
	table.insert(hazardsConns, root.ChildAdded:Connect(function(inst)
		addTrashModel(inst)
	end))
	table.insert(hazardsConns, root.ChildRemoved:Connect(function(inst)
		if trashButtons[inst] then removeTrashModel(inst) end
	end))
	table.insert(hazardsConns, root.AncestryChanged:Connect(function(_, parent)
		if not parent then disconnectHazardsWatch() end
	end))
end

-- Rebind if Hazards is recreated; keeps list accurate
task.spawn(function()
	local last
	while pageTrash.Parent do
		local root = getHazardsRoot()
		if root ~= last then
			attachHazardsWatch(root)
			last = root
		end
		task.wait(1.0)
	end
end)

-- [Shop logic â€” direct children only]
local function getVendorsRoot()
	local env = workspace:FindFirstChild("Environment")
	if not env then return nil end
	return env:FindFirstChild("Vendors")
end

local function tpToModel(m)
	if not m or not m:IsA("Model") then return end
	local char = player.Character or player.CharacterAdded:Wait()
	if not char then return end
	local cf
	local ok, pivot = pcall(function() return m:GetPivot() end)
	if ok then
		cf = pivot
	elseif m.PrimaryPart then
		cf = m.PrimaryPart.CFrame
	else
		local p = m:FindFirstChildWhichIsA("BasePart", true)
		if p then cf = p.CFrame end
	end
	if not cf then return end
	char:PivotTo(cf * CFrame.new(0, 4, 0))
end

-- Storage
local shopButtons = {}          -- [Model] = TextButton
local shopNameConn = {}         -- [Model] = RBXScriptConnection
local vendorsConns = {}         -- { RBXScriptConnection }
local observedVendors = nil

local function addVendorModel(m)
	if shopButtons[m] then return end
	local b = makeShopButton(m.Name)
	b.Parent = shopList
	shopButtons[m] = b
	b.MouseButton1Click:Connect(function() tpToModel(m) end)
	shopNameConn[m] = m:GetPropertyChangedSignal("Name"):Connect(function()
		b.Name = m.Name
		b.Text = m.Name
	end)
end

local function removeVendorModel(m)
	local b = shopButtons[m]
	if b then b:Destroy() end
	shopButtons[m] = nil
	if shopNameConn[m] then shopNameConn[m]:Disconnect() shopNameConn[m] = nil end
end

local function clearVendors()
	for m,_ in pairs(shopButtons) do removeVendorModel(m) end
end

-- Populate ONLY direct children that are Models
local function populateVendors(root)
	clearVendors()
	if not root then return end
	for _, child in ipairs(root:GetChildren()) do
		if child:IsA("Model") then
			addVendorModel(child)
		end
	end
end

local function disconnectVendorsWatch()
	for _, c in ipairs(vendorsConns) do if c then c:Disconnect() end end
	vendorsConns = {}
	observedVendors = nil
end

local function attachVendorsWatch(root)
	disconnectVendorsWatch()
	if not root then return end
	observedVendors = root

	populateVendors(root)

	-- Only watch direct children (no descendants)
	table.insert(vendorsConns, root.ChildAdded:Connect(function(inst)
		if inst:IsA("Model") then addVendorModel(inst) end
	end))
	table.insert(vendorsConns, root.ChildRemoved:Connect(function(inst)
		if shopButtons[inst] then removeVendorModel(inst) end
	end))
	table.insert(vendorsConns, root.AncestryChanged:Connect(function(_, parent)
		if not parent then disconnectVendorsWatch() end
	end))
end

-- Rebind if Vendors is recreated; keeps the list current
task.spawn(function()
	local last
	while pageShop.Parent do
		local root = getVendorsRoot()
		if root ~= last then
			attachVendorsWatch(root)
			last = root
		end
		task.wait(1.0)
	end
end)

-- Initial selection
local currentIndex = 1
pageList[currentIndex].Visible = true
pageList[currentIndex].Position = UDim2.new(0,0,0,0)

-- Update tab visuals (color + underline)
local function setTabVisual(activeIndex)
	for i, b in ipairs(tabList) do
		local isActive = (i == activeIndex)
		local bg = isActive and TAB_SEL or TAB
		tween(b, TweenInfo.new(0.15), {BackgroundColor3 = bg})
		local u = b:FindFirstChild("Underline")
		if u then
			if isActive then
				tween(u, TweenInfo.new(0.20, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(1, 0, 0, 3)})
			else
				tween(u, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.new(0, 0, 0, 3)})
			end
		end
	end
	tween(win, TweenInfo.new(0.2), {BackgroundColor3 = BG})
end
setTabVisual(currentIndex)

-- Directional swipe transition
local function slideTo(targetIndex)
	if targetIndex == currentIndex then
		setTabVisual(currentIndex)
		return
	end
	local oldPage = pageList[currentIndex]
	local newPage = pageList[targetIndex]
	local goingRight = targetIndex > currentIndex
	local incomingX = goingRight and -1 or 1
	local outgoingX = goingRight and  1 or -1

	newPage.Visible = true
	newPage.Position = UDim2.new(incomingX,0,0,0)

	local info = TweenInfo.new(0.28, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local tIn  = tween(newPage, info, {Position = UDim2.new(0,0,0,0)})
	local tOut = tween(oldPage, info, {Position = UDim2.new(outgoingX,0,0,0)})
	tIn.Completed:Wait()

	oldPage.Visible = false
	oldPage.Position = UDim2.new(0,0,0,0)
	currentIndex = targetIndex
	setTabVisual(currentIndex)
end

-- Hook tabs
tabItems.MouseButton1Click:Connect(function() slideTo(1) end)
tabAmmo.MouseButton1Click:Connect(function()  slideTo(2) end)
tabMisc.MouseButton1Click:Connect(function()  slideTo(3) end)
tabShop.MouseButton1Click:Connect(function() slideTo(4) end)

-- Click bindings
tabCrates.MouseButton1Click:Connect(function() slideTo(5) end)
tabTrash.MouseButton1Click:Connect(function()  slideTo(6) end)

----------------------------------------------------------------------
-- Dragging (drag the title bar; clicking tabs won't drag)
----------------------------------------------------------------------
local dragging, dragStart, startPos, dragInput
local function pointIn(obj, p)
	local pos, size = obj.AbsolutePosition, obj.AbsoluteSize
	return p.X >= pos.X and p.X <= pos.X + size.X and p.Y >= pos.Y and p.Y <= pos.Y + size.Y
end

titleBar.InputBegan:Connect(function(input)
	if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then
		return
	end
	for _, child in ipairs(tabsStrip:GetChildren()) do
		if child:IsA("GuiButton") and pointIn(child, input.Position) then
			return
		end
	end
	dragging = true
	dragStart = input.Position
	startPos = win.Position
	input.Changed:Connect(function()
		if input.UserInputState == Enum.UserInputState.End then dragging = false end
	end)
end)

titleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		win.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

----------------------------------------------------------------------
-- Left Control: modern zoom-fade toggle (minimize/restore)
----------------------------------------------------------------------
local scale = Instance.new("UIScale")
scale.Scale = 1
scale.Parent = win

local fader = Instance.new("Frame")
fader.BackgroundColor3 = Color3.fromRGB(18, 6, 28)
fader.BackgroundTransparency = 1
fader.BorderSizePixel = 0
fader.Size = UDim2.fromScale(1,1)
fader.ZIndex = 999
fader.Parent = win
corner(fader, 14)

local homePos = win.Position
local isOpen, animLock, windowReady = false, false, false

local function openWindow()
	if animLock or isOpen or not windowReady then return end
	animLock = true
	win.Visible = true
	scale.Scale = 0.96
	fader.BackgroundTransparency = 0
	win.Position = homePos + UDim2.fromOffset(0, 8)

	tween(fader, TweenInfo.new(0.28, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
	tween(win,   TweenInfo.new(0.26, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = homePos})
	local up = tween(scale, TweenInfo.new(0.16, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {Scale = 1.03})
	up.Completed:Wait()
	tween(scale, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Scale = 1})

	isOpen, animLock = true, false
end

local function closeWindow()
	if animLock or not isOpen or not windowReady then return end
	animLock = true
	tween(fader, TweenInfo.new(0.20, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 0})
	tween(win,   TweenInfo.new(0.24, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = homePos + UDim2.fromOffset(0, 8)})
	local down = tween(scale, TweenInfo.new(0.24, Enum.EasingStyle.Quint, Enum.EasingDirection.In), {Scale = 0.94})
	down.Completed:Wait()
	win.Visible = false
	isOpen, animLock = false, false
end

local function toggleWindow()
	if not windowReady then return end
	if isOpen then closeWindow() else openWindow() end
end

-- Replace the old LeftControl handler with this N-key handler.
-- This respects your zoom-fade open/close via toggleWindow() and
-- ignores key presses while typing in a TextBox (e.g., search bar).

UIS.InputBegan:Connect(function(input, processed)
	if processed then return end
	-- Don't toggle while typing inside a TextBox
	if UIS:GetFocusedTextBox() then return end

	if input.UserInputType == Enum.UserInputType.Keyboard
		and input.KeyCode == Enum.KeyCode.N then
		toggleWindow() -- uses your existing open/close animation
	end
end)

----------------------------------------------------------------------
-- Full-screen cinematic intro (covers CoreGui). Includes one-time SFX.
----------------------------------------------------------------------
local function safeSetCoreAll(enabled)
	for i = 1, 40 do
		local ok1 = pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, enabled) end)
		local ok2 = pcall(function() StarterGui:SetCore("TopbarEnabled", enabled) end)
		if ok1 and ok2 then return end
		task.wait(0.1)
	end
end

local function playStunningIntro()
	local introGui = Instance.new("ScreenGui")
	introGui.Name = "PT_Intro"
	introGui.IgnoreGuiInset = true         -- fill the entire screen
	introGui.ResetOnSpawn = false
	introGui.DisplayOrder = 1_000_000     -- absolutely on top
	introGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	introGui.Parent = playerGui

	-- Disable Roblox CoreGui so nothing sits above the intro
	safeSetCoreAll(false)

	-- Play one-time intro SFX
	local sfx = Instance.new("Sound")
	sfx.SoundId = "rbxassetid://7112183471"
	sfx.Volume = 0.7
	sfx.RollOffMode = Enum.RollOffMode.Linear -- 2D UI sound via SoundService
	sfx.Parent = SoundService
	sfx:Play()
	sfx.Ended:Connect(function() sfx:Destroy() end)

	local overlay = Instance.new("Frame")
	overlay.Name = "CinematicOverlay"
	overlay.BackgroundColor3 = BG
	overlay.Size = UDim2.fromScale(1, 1)
	overlay.ZIndex = 100
	overlay.ClipsDescendants = true
	overlay.Parent = introGui

	-- Vignette
	local vignette = Instance.new("Frame")
	vignette.BackgroundTransparency = 1
	vignette.Size = UDim2.fromScale(1, 1)
	vignette.ZIndex = 102
	vignette.Parent = overlay
	local vigGrad = Instance.new("UIGradient")
	vigGrad.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(30, 12, 45)),
		ColorSequenceKeypoint.new(0.60, Color3.fromRGB(30, 12, 45)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(15, 5, 25))
	}
	vigGrad.Rotation = 90
	vigGrad.Parent = vignette

	-- Parallax stars
	local starRoot = Instance.new("Frame")
	starRoot.BackgroundTransparency = 1
	starRoot.Size = UDim2.fromScale(1,1)
	starRoot.ZIndex = 103
	starRoot.Parent = overlay

	local layers = {
		{count = 120, speed = 10,  size = Vector2.new(2,2), alpha = 0.45},
		{count = 70,  speed = 25,  size = Vector2.new(3,3), alpha = 0.55},
		{count = 28,  speed = 55,  size = Vector2.new(4,4), alpha = 0.70},
	}
	local movers = {}
	local function makeStar(parent, sz, a)
		local s = Instance.new("Frame")
		s.BackgroundColor3 = WHITE
		s.BackgroundTransparency = 1 - a
		s.Size = UDim2.fromOffset(sz.X, sz.Y)
		s.Position = UDim2.fromScale(math.random(), math.random())
		s.ZIndex = 103
		s.Parent = parent
		local glow = Instance.new("Frame")
		glow.AnchorPoint = Vector2.new(0.5, 0.5)
		glow.Position = UDim2.fromScale(0.5, 0.5)
		glow.Size = UDim2.fromOffset(sz.X*3, sz.Y*3)
		glow.BackgroundColor3 = MAGENTA:Lerp(CYAN, math.random())
		glow.BackgroundTransparency = 0.82
		glow.Parent = s
		corner(glow, math.max(sz.X, sz.Y))
		corner(s, math.max(2, math.max(sz.X, sz.Y)))
		return s
	end
	for _, l in ipairs(layers) do
		for i=1, l.count do
			local s = makeStar(starRoot, l.size, l.alpha)
			table.insert(movers, {s = s, speed = l.speed})
		end
	end
	local conn = RunService.RenderStepped:Connect(function(dt)
		for _, m in ipairs(movers) do
			local p = m.s.Position
			local x = p.X.Scale + (m.speed * dt)/100
			local y = p.Y.Scale + (m.speed * dt)/300
			if x > 1.1 then x = -0.1 end
			if y > 1.1 then y = -0.1 end
			m.s.Position = UDim2.fromScale(x, y)
		end
	end)

	-- Shooting streaks
	local streakRoot = Instance.new("Frame")
	streakRoot.BackgroundTransparency = 1
	streakRoot.Size = UDim2.fromScale(1,1)
	streakRoot.ZIndex = 104
	streakRoot.Parent = overlay
	local function spawnStreak()
		local st = Instance.new("Frame")
		st.BackgroundColor3 = CYAN:Lerp(MAGENTA, math.random())
		st.BackgroundTransparency = 0.15
		st.Size = UDim2.fromOffset(math.random(120, 220), 2)
		st.AnchorPoint = Vector2.new(0.5, 0.5)
		local y = math.random()
		st.Position = UDim2.fromScale(-0.1, y)
		st.Rotation = -10 + math.random(-6, 6)
		st.Parent = streakRoot
		local g = Instance.new("UIGradient")
		g.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, WHITE),
			ColorSequenceKeypoint.new(0.3, WHITE),
			ColorSequenceKeypoint.new(1, WHITE)
		}
		g.Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 1),
			NumberSequenceKeypoint.new(0.15, 0.3),
			NumberSequenceKeypoint.new(0.85, 0.3),
			NumberSequenceKeypoint.new(1, 1)
		}
		g.Parent = st
		tween(st, TweenInfo.new(0.9, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.fromScale(1.2, y)}).Completed:Wait()
		st:Destroy()
	end
	task.spawn(function()
		while overlay.Parent do
			spawnStreak()
			task.wait(math.random(12, 22)/100)
		end
	end)

	-- Splash image (rounded)
	local splash = Instance.new("ImageLabel")
	splash.Name = "SplashImage"
	splash.BackgroundTransparency = 1
	splash.AnchorPoint = Vector2.new(0.5, 0.5)
 	splash.Position = UDim2.fromScale(0.5, 0.5)
	splash.Size = UDim2.fromOffset(220, 140)
	splash.Image = "rbxassetid://127277196439432"
	splash.ScaleType = Enum.ScaleType.Fit
	splash.ZIndex = 110
	splash.Parent = overlay
	corner(splash, 16)

	-- Timings: expand 3.5s; shrink extended 2.0s; fade 1.0s
	local EXPAND_TIME, SHRINK_TIME, FADE_TIME = 3.5, 2.0, 1.0

	tween(splash, TweenInfo.new(EXPAND_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromScale(1,1)}).Completed:Wait()
	tween(splash, TweenInfo.new(SHRINK_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(280,175)}).Completed:Wait()
	tween(splash, TweenInfo.new(FADE_TIME), {ImageTransparency = 1}).Completed:Wait()

	if conn then conn:Disconnect() end
	introGui:Destroy()
	safeSetCoreAll(true)

	-- Also call again right after your intro re-enables CoreGui:
	disableBackpackPermanently()

	-- Reveal the main GUI and arm the toggle
	win.Visible = true
	homePos = win.Position
	isOpen = true
	windowReady = true
end

-- Run the intro (sound plays once here)
playStunningIntro()
